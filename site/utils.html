
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
        <meta name="author" content="Patrick Cahan">
      
      
      
        <link rel="prev" href="refs.html">
      
      
        <link rel="next" href="classifier.html">
      
      
      <link rel="icon" href="img/logo.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.49">
    
    
      
        <title>Utility functions - pySingleCellNet</title>
      
    
    
      <link rel="stylesheet" href="assets/stylesheets/main.6f8fc17f.min.css">
      
        
        <link rel="stylesheet" href="assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Noto Sans";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="assets/_mkdocstrings.css">
    
      <link rel="stylesheet" href="stylesheets/extra.css">
    
    <script>__md_scope=new URL(".",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="light-blue" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#utilities" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="." title="pySingleCellNet" class="md-header__button md-logo" aria-label="pySingleCellNet" data-md-component="logo">
      
  <img src="img/logoGlow.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            pySingleCellNet
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Utility functions
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/CahanLab/PySingleCellNet" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



  

<nav class="md-nav md-nav--primary md-nav--integrated" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="." title="pySingleCellNet" class="md-nav__button md-logo" aria-label="pySingleCellNet" data-md-component="logo">
      
  <img src="img/logoGlow.png" alt="logo">

    </a>
    pySingleCellNet
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/CahanLab/PySingleCellNet" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="install.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Installation
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Tutorials
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Tutorials
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="notebooks/quickstart.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Quickstart
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="notebooks/categorize.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Explore
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="training_data.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Training data
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="refs.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    References
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" checked>
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    API
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            API
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Utility functions
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="utils.html" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Utility functions
  </span>
  

      </a>
      
        

  

<nav class="md-nav md-nav--secondary" aria-label="On this page">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      On this page
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.utils" class="md-nav__link">
    <span class="md-ellipsis">
      utils
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.assign_optimal_cluster" class="md-nav__link">
    <span class="md-ellipsis">
      assign_optimal_cluster
    </span>
  </a>
  
    <nav class="md-nav" aria-label="assign_optimal_cluster">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.assign_optimal_cluster--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.assign_optimal_cluster--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.build_knn_graph" class="md-nav__link">
    <span class="md-ellipsis">
      build_knn_graph
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.cluster_subclusters" class="md-nav__link">
    <span class="md-ellipsis">
      cluster_subclusters
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.combine_pca_scores" class="md-nav__link">
    <span class="md-ellipsis">
      combine_pca_scores
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.create_gene_structure_dict_by_stage" class="md-nav__link">
    <span class="md-ellipsis">
      create_gene_structure_dict_by_stage
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.extract_top_bottom_genes" class="md-nav__link">
    <span class="md-ellipsis">
      extract_top_bottom_genes
    </span>
  </a>
  
    <nav class="md-nav" aria-label="extract_top_bottom_genes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.extract_top_bottom_genes--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters:
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.extract_top_bottom_genes--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns:
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.extract_top_bottom_genes--raises" class="md-nav__link">
    <span class="md-ellipsis">
      Raises:
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.filter_adata_by_group_size" class="md-nav__link">
    <span class="md-ellipsis">
      filter_adata_by_group_size
    </span>
  </a>
  
    <nav class="md-nav" aria-label="filter_adata_by_group_size">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.filter_adata_by_group_size--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters:
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.filter_adata_by_group_size--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns:
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.filter_adata_by_group_size--raises" class="md-nav__link">
    <span class="md-ellipsis">
      Raises:
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.filter_anndata_slots" class="md-nav__link">
    <span class="md-ellipsis">
      filter_anndata_slots
    </span>
  </a>
  
    <nav class="md-nav" aria-label="filter_anndata_slots">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.filter_anndata_slots--filtered_adata-is-the-modified-copy-adata-remains-unchanged" class="md-nav__link">
    <span class="md-ellipsis">
      filtered_adata is the modified copy, adata remains unchanged.
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.filter_gene_list" class="md-nav__link">
    <span class="md-ellipsis">
      filter_gene_list
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.find_elbow" class="md-nav__link">
    <span class="md-ellipsis">
      find_elbow
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.find_knee_point" class="md-nav__link">
    <span class="md-ellipsis">
      find_knee_point
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.generate_joint_graph" class="md-nav__link">
    <span class="md-ellipsis">
      generate_joint_graph
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.get_unique_colors" class="md-nav__link">
    <span class="md-ellipsis">
      get_unique_colors
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.mito_rib" class="md-nav__link">
    <span class="md-ellipsis">
      mito_rib
    </span>
  </a>
  
    <nav class="md-nav" aria-label="mito_rib">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.mito_rib--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.mito_rib--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.mito_rib_heme" class="md-nav__link">
    <span class="md-ellipsis">
      mito_rib_heme
    </span>
  </a>
  
    <nav class="md-nav" aria-label="mito_rib_heme">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.mito_rib_heme--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.mito_rib_heme--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.rank_genes_subsets" class="md-nav__link">
    <span class="md-ellipsis">
      rank_genes_subsets
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.read_gmt" class="md-nav__link">
    <span class="md-ellipsis">
      read_gmt
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.reassign_selected_clusters" class="md-nav__link">
    <span class="md-ellipsis">
      reassign_selected_clusters
    </span>
  </a>
  
    <nav class="md-nav" aria-label="reassign_selected_clusters">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.reassign_selected_clusters--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.reassign_selected_clusters--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.rename_cluster_labels" class="md-nav__link">
    <span class="md-ellipsis">
      rename_cluster_labels
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.score_sex" class="md-nav__link">
    <span class="md-ellipsis">
      score_sex
    </span>
  </a>
  
    <nav class="md-nav" aria-label="score_sex">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.score_sex--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.score_sex--raises" class="md-nav__link">
    <span class="md-ellipsis">
      Raises
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.score_sex--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.sort_obs_table" class="md-nav__link">
    <span class="md-ellipsis">
      sort_obs_table
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.split_adata_indices" class="md-nav__link">
    <span class="md-ellipsis">
      split_adata_indices
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.utils.write_gmt" class="md-nav__link">
    <span class="md-ellipsis">
      write_gmt
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="classifier.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Classifier functions
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="plotting.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Plotting functions
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="utilities">Utilities</h1>
<p>Miscellaneous functions</p>


<div class="doc doc-object doc-module">



<a id="pySingleCellNet.utils"></a>
    <div class="doc doc-contents first">








  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.utils.assign_optimal_cluster" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">assign_optimal_cluster</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">assign_optimal_cluster</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">cluster_reports</span><span class="p">,</span> <span class="n">new_col</span><span class="o">=</span><span class="s1">&#39;optimal_cluster&#39;</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Determine the optimal cluster label per cell across multiple cluster assignments
by comparing F1-scores, then prepend the chosen label with the name of the .obs
column that provided it.</p>
<h5 id="pySingleCellNet.utils.assign_optimal_cluster--parameters">Parameters</h5>
<p>adata : anndata.AnnData
    The annotated single-cell dataset.
cluster_reports : dict[str, pd.DataFrame]
    A dictionary where keys are column names in <code>adata.obs</code> (each key 
    corresponds to one clustering scheme), and values are DataFrames 
    with classification metrics including 'Label' and 'F1-Score'.
new_col : str, optional
    The name of the new <code>.obs</code> column in which the optimal cluster labels 
    will be stored. Default is "optimal_cluster".</p>
<h5 id="pySingleCellNet.utils.assign_optimal_cluster--returns">Returns</h5>
<p>None
    The function adds a new column to <code>adata.obs</code> but does not return anything.</p>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/utils/cell.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">assign_optimal_cluster</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">cluster_reports</span><span class="p">,</span> <span class="n">new_col</span><span class="o">=</span><span class="s2">&quot;optimal_cluster&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the optimal cluster label per cell across multiple cluster assignments</span>
<span class="sd">    by comparing F1-scores, then prepend the chosen label with the name of the .obs</span>
<span class="sd">    column that provided it.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adata : anndata.AnnData</span>
<span class="sd">        The annotated single-cell dataset.</span>
<span class="sd">    cluster_reports : dict[str, pd.DataFrame]</span>
<span class="sd">        A dictionary where keys are column names in `adata.obs` (each key </span>
<span class="sd">        corresponds to one clustering scheme), and values are DataFrames </span>
<span class="sd">        with classification metrics including &#39;Label&#39; and &#39;F1-Score&#39;.</span>
<span class="sd">    new_col : str, optional</span>
<span class="sd">        The name of the new `.obs` column in which the optimal cluster labels </span>
<span class="sd">        will be stored. Default is &quot;optimal_cluster&quot;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        The function adds a new column to `adata.obs` but does not return anything.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Prepare a list to hold the chosen cluster label (prepended with obs_col name) per cell</span>
    <span class="n">optimal_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">n_obs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

    <span class="c1"># Convert each cluster report into a dictionary for faster F1 lookups:</span>
    <span class="c1"># For each clustering key, map cluster_label -&gt; F1_score</span>
    <span class="n">f1_lookup_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">obs_col</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">cluster_reports</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># Convert the &quot;Label&quot; -&gt; &quot;F1-Score&quot; DataFrame to a dictionary for quick lookups</span>
        <span class="n">f1_lookup_dict</span><span class="p">[</span><span class="n">obs_col</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Label&quot;</span><span class="p">],</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;F1-Score&quot;</span><span class="p">]))</span>

    <span class="c1"># Iterate over each cell in adata</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">n_obs</span><span class="p">):</span>
        <span class="n">best_f1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">best_label_full</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Will store &quot;&lt;obs_col&gt;_&lt;cluster_label&gt;&quot;</span>

        <span class="c1"># Check each cluster assignment</span>
        <span class="k">for</span> <span class="n">obs_col</span><span class="p">,</span> <span class="n">label_to_f1</span> <span class="ow">in</span> <span class="n">f1_lookup_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Current cell&#39;s cluster label in this assignment</span>
            <span class="n">cell_label</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">obs_col</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># Lookup F1 score (if label doesn&#39;t exist in the classification report, default to -1)</span>
            <span class="n">f1</span> <span class="o">=</span> <span class="n">label_to_f1</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cell_label</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Update if this is a higher F1</span>
            <span class="k">if</span> <span class="n">f1</span> <span class="o">&gt;</span> <span class="n">best_f1</span><span class="p">:</span>
                <span class="n">best_f1</span> <span class="o">=</span> <span class="n">f1</span>
                <span class="c1"># Prepend the obs_col to ensure uniqueness across different clustering schemes</span>
                <span class="n">best_label_full</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">obs_col</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">cell_label</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">optimal_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">best_label_full</span>

    <span class="c1"># Store the new labels in an adata.obs column</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">new_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">optimal_labels</span>
    <span class="c1"># convert to categorical</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">new_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">new_col</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.utils.build_knn_graph" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">build_knn_graph</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">build_knn_graph</span><span class="p">(</span><span class="n">correlation_matrix</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Build a k-nearest neighbors (kNN) graph from a correlation matrix.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>correlation_matrix</code></b>
              (<code>ndarray</code>)
          –
          <div class="doc-md-description">
            <p>Square correlation matrix.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>labels</code></b>
              (<code>list</code>)
          –
          <div class="doc-md-description">
            <p>Node labels corresponding to the rows/columns of the correlation matrix.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>k</code></b>
              (<code>int</code>, default:
                  <code>5</code>
)
          –
          <div class="doc-md-description">
            <p>Number of nearest neighbors to connect each node to.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
          –
          <div class="doc-md-description">
            <p>igraph.Graph: kNN graph.</p>
          </div>
        </li>
    </ul>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/utils/adataTools.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">build_knn_graph</span><span class="p">(</span><span class="n">correlation_matrix</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a k-nearest neighbors (kNN) graph from a correlation matrix.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        correlation_matrix (ndarray): Square correlation matrix.</span>
<span class="sd">        labels (list): Node labels corresponding to the rows/columns of the correlation matrix.</span>
<span class="sd">        k (int): Number of nearest neighbors to connect each node to.</span>

<span class="sd">    Returns:</span>
<span class="sd">        igraph.Graph: kNN graph.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># import igraph as ig</span>

    <span class="c1"># Ensure the correlation matrix is square</span>
    <span class="k">assert</span> <span class="n">correlation_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">correlation_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;Matrix must be square.&quot;</span>

    <span class="c1"># Initialize the graph</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">g</span><span class="o">.</span><span class="n">add_vertices</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">labels</span>  <span class="c1"># Add node labels</span>

    <span class="c1"># Build kNN edges</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c1"># Get k largest correlations (excluding self-correlation)</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">correlation_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])[</span><span class="o">-</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Exclude the node itself</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">correlation_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">g</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.utils.cluster_subclusters" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">cluster_subclusters</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">cluster_subclusters</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">cluster_column</span><span class="o">=</span><span class="s1">&#39;leiden&#39;</span><span class="p">,</span> <span class="n">cluster_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="s1">&#39;counts&#39;</span><span class="p">,</span> <span class="n">n_hvg</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">n_pcs</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">leiden_resolution</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">subcluster_col_name</span><span class="o">=</span><span class="s1">&#39;subcluster&#39;</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Subcluster a specified cluster (or all clusters) within an AnnData object by recomputing HVGs, PCA,
kNN graph, and Leiden clustering. Updates the AnnData object in-place, adding or updating
the <code>subcluster_col_name</code> column in <code>.obs</code> with new labels prefixed by the original cluster.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>adata</code></b>
              (<code><span title="anndata.AnnData">AnnData</span></code>)
          –
          <div class="doc-md-description">
            <p>AnnData
The AnnData object containing precomputed clusters in <code>.obs[cluster_column]</code>.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>cluster_column</code></b>
              (<code>str</code>, default:
                  <code>&#39;leiden&#39;</code>
)
          –
          <div class="doc-md-description">
            <p>str, optional
Name of the <code>.obs</code> column holding the original cluster assignments. Default is 'leiden'.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>cluster_name</code></b>
              (<code>str</code>, default:
                  <code>None</code>
)
          –
          <div class="doc-md-description">
            <p>str or None, optional
Specific cluster label to subcluster. If <code>None</code>, applies to all clusters. Default is None.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>layer</code></b>
              (<code>str</code>, default:
                  <code>&#39;counts&#39;</code>
)
          –
          <div class="doc-md-description">
            <p>str, optional
Layer name in <code>adata.layers</code> to use for HVG detection. Default is 'counts'.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>n_hvg</code></b>
              (<code>int</code>, default:
                  <code>2000</code>
)
          –
          <div class="doc-md-description">
            <p>int, optional
Number of highly variable genes to select per cluster. Default is 2000.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>n_pcs</code></b>
              (<code>int</code>, default:
                  <code>40</code>
)
          –
          <div class="doc-md-description">
            <p>int, optional
Number of principal components to compute. Default is 40.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>n_neighbors</code></b>
              (<code>int</code>, default:
                  <code>10</code>
)
          –
          <div class="doc-md-description">
            <p>int, optional
Number of neighbors for the kNN graph. Default is 10.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>leiden_resolution</code></b>
              (<code>float</code>, default:
                  <code>0.25</code>
)
          –
          <div class="doc-md-description">
            <p>float, optional
Resolution parameter for Leiden clustering. Default is 0.25.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>subcluster_col_name</code></b>
              (<code>str</code>, default:
                  <code>&#39;subcluster&#39;</code>
)
          –
          <div class="doc-md-description">
            <p>str, optional
Name of the <code>.obs</code> column to store subcluster labels. Default is 'subcluster'.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>ValueError</code>
            –
          <div class="doc-md-description">
            <p>If <code>cluster_column</code> not in <code>adata.obs</code>.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code>ValueError</code>
            –
          <div class="doc-md-description">
            <p>If <code>layer</code> not in <code>adata.layers</code>.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code>ValueError</code>
            –
          <div class="doc-md-description">
            <p>If <code>cluster_name</code> is specified but not found in <code>adata.obs[cluster_column]</code>.</p>
          </div>
        </li>
    </ul>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/utils/cell.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 14</span>
<span class="normal"> 15</span>
<span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">cluster_subclusters</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span>
    <span class="n">cluster_column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;leiden&#39;</span><span class="p">,</span>
    <span class="n">cluster_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">layer</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;counts&#39;</span><span class="p">,</span>
    <span class="n">n_hvg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">,</span>
    <span class="n">n_pcs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
    <span class="n">n_neighbors</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">leiden_resolution</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.25</span><span class="p">,</span>
    <span class="n">subcluster_col_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;subcluster&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Subcluster a specified cluster (or all clusters) within an AnnData object by recomputing HVGs, PCA,</span>
<span class="sd">    kNN graph, and Leiden clustering. Updates the AnnData object in-place, adding or updating</span>
<span class="sd">    the `subcluster_col_name` column in `.obs` with new labels prefixed by the original cluster.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata: AnnData</span>
<span class="sd">            The AnnData object containing precomputed clusters in `.obs[cluster_column]`.</span>
<span class="sd">        cluster_column: str, optional</span>
<span class="sd">            Name of the `.obs` column holding the original cluster assignments. Default is &#39;leiden&#39;.</span>
<span class="sd">        cluster_name: str or None, optional</span>
<span class="sd">            Specific cluster label to subcluster. If `None`, applies to all clusters. Default is None.</span>
<span class="sd">        layer: str, optional</span>
<span class="sd">            Layer name in `adata.layers` to use for HVG detection. Default is &#39;counts&#39;.</span>
<span class="sd">        n_hvg: int, optional</span>
<span class="sd">            Number of highly variable genes to select per cluster. Default is 2000.</span>
<span class="sd">        n_pcs: int, optional</span>
<span class="sd">            Number of principal components to compute. Default is 40.</span>
<span class="sd">        n_neighbors: int, optional</span>
<span class="sd">            Number of neighbors for the kNN graph. Default is 10.</span>
<span class="sd">        leiden_resolution: float, optional</span>
<span class="sd">            Resolution parameter for Leiden clustering. Default is 0.25.</span>
<span class="sd">        subcluster_col_name: str, optional</span>
<span class="sd">            Name of the `.obs` column to store subcluster labels. Default is &#39;subcluster&#39;.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If `cluster_column` not in `adata.obs`.</span>
<span class="sd">        ValueError: If `layer` not in `adata.layers`.</span>
<span class="sd">        ValueError: If `cluster_name` is specified but not found in `adata.obs[cluster_column]`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Error checking</span>
    <span class="k">if</span> <span class="n">cluster_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cluster column &#39;</span><span class="si">{</span><span class="n">cluster_column</span><span class="si">}</span><span class="s2">&#39; not found in adata.obs&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">layer</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Layer &#39;</span><span class="si">{</span><span class="n">layer</span><span class="si">}</span><span class="s2">&#39; not found in adata.layers&quot;</span><span class="p">)</span>

    <span class="c1"># Convert original clusters to string</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;original_cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cluster_column</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>

    <span class="c1"># Ensure subcluster column exists</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">subcluster_col_name</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="c1"># Validate cluster_name</span>
    <span class="n">unique_clusters</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;original_cluster&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">cluster_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">cluster_name</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unique_clusters</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cluster &#39;</span><span class="si">{</span><span class="n">cluster_name</span><span class="si">}</span><span class="s2">&#39; not found in adata.obs[&#39;</span><span class="si">{</span><span class="n">cluster_column</span><span class="si">}</span><span class="s2">&#39;]&quot;</span>
            <span class="p">)</span>
        <span class="n">clusters_to_process</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster_name</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">clusters_to_process</span> <span class="o">=</span> <span class="n">unique_clusters</span>

    <span class="c1"># Iterate and subcluster</span>
    <span class="k">for</span> <span class="n">orig</span> <span class="ow">in</span> <span class="n">clusters_to_process</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;original_cluster&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">orig</span>
        <span class="n">sub</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># 1) Compute HVGs</span>
        <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">highly_variable_genes</span><span class="p">(</span>
            <span class="n">sub</span><span class="p">,</span>
            <span class="n">flavor</span><span class="o">=</span><span class="s1">&#39;seurat_v3&#39;</span><span class="p">,</span>
            <span class="n">n_top_genes</span><span class="o">=</span><span class="n">n_hvg</span><span class="p">,</span>
            <span class="n">layer</span><span class="o">=</span><span class="n">layer</span>
        <span class="p">)</span>

        <span class="c1"># 2) PCA</span>
        <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">pca</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">n_comps</span><span class="o">=</span><span class="n">n_pcs</span><span class="p">,</span> <span class="n">use_highly_variable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># 3) kNN</span>
        <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">use_rep</span><span class="o">=</span><span class="s1">&#39;X_pca&#39;</span><span class="p">)</span>

        <span class="c1"># 4) Leiden</span>
        <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">leiden</span><span class="p">(</span>
            <span class="n">sub</span><span class="p">,</span>
            <span class="n">resolution</span><span class="o">=</span><span class="n">leiden_resolution</span><span class="p">,</span>
            <span class="n">flavor</span><span class="o">=</span><span class="s1">&#39;igraph&#39;</span><span class="p">,</span>
            <span class="n">n_iterations</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">key_added</span><span class="o">=</span><span class="s1">&#39;leiden_sub&#39;</span>
        <span class="p">)</span>

        <span class="c1"># Prefix and assign back</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="n">orig</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">sub</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;leiden_sub&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">))</span><span class="o">.</span><span class="n">values</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">subcluster_col_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">labels</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.utils.combine_pca_scores" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">combine_pca_scores</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">combine_pca_scores</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">n_pcs</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">score_key</span><span class="o">=</span><span class="s1">&#39;SCN_score&#39;</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Combine principal components and gene set scores into a single matrix.</p>
<p>This function merges the top principal components (PCs) and gene set scores 
into a combined matrix stored in <code>.obsm</code>.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>adata</code></b>
              (<code>AnnData</code>)
          –
          <div class="doc-md-description">
            <p>AnnData object containing PCA results and gene set scores in <code>.obsm</code>.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>n_pcs</code></b>
              (<code>int</code>, default:
                  <code>50</code>
)
          –
          <div class="doc-md-description">
            <p>Number of top PCs to include. Default is 50.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>score_key</code></b>
              (<code>str</code>, default:
                  <code>&#39;SCN_score&#39;</code>
)
          –
          <div class="doc-md-description">
            <p>Key in <code>.obsm</code> where gene set scores are stored. Default is <code>'SCN_score'</code>.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>ValueError</code>
            –
          <div class="doc-md-description">
            <p>If <code>'X_pca'</code> is not found in <code>.obsm</code>.  </p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code>ValueError</code>
            –
          <div class="doc-md-description">
            <p>If <code>score_key</code> is missing in <code>.obsm</code>.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
<b><code>None</code></b>          –
          <div class="doc-md-description">
            <p>Updates <code>adata</code> by adding the combined matrix to <code>.obsm['X_pca_scores_combined']</code>.</p>
          </div>
        </li>
    </ul>


<details class="example" open>
  <summary>Example</summary>
  <blockquote>
<blockquote>
<blockquote>
<p>combine_pca_scores(adata, n_pcs=30, score_key='GeneSet_Score')</p>
</blockquote>
</blockquote>
</blockquote>
</details>
            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/utils/adataTools.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">combine_pca_scores</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">n_pcs</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">score_key</span><span class="o">=</span><span class="s1">&#39;SCN_score&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Combine principal components and gene set scores into a single matrix.</span>

<span class="sd">    This function merges the top principal components (PCs) and gene set scores </span>
<span class="sd">    into a combined matrix stored in `.obsm`.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata (AnnData): </span>
<span class="sd">            AnnData object containing PCA results and gene set scores in `.obsm`.</span>
<span class="sd">        n_pcs (int, optional): </span>
<span class="sd">            Number of top PCs to include. Default is 50.</span>
<span class="sd">        score_key (str, optional): </span>
<span class="sd">            Key in `.obsm` where gene set scores are stored. Default is `&#39;SCN_score&#39;`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If `&#39;X_pca&#39;` is not found in `.obsm`.  </span>
<span class="sd">        ValueError: If `score_key` is missing in `.obsm`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: Updates `adata` by adding the combined matrix to `.obsm[&#39;X_pca_scores_combined&#39;]`.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; combine_pca_scores(adata, n_pcs=30, score_key=&#39;GeneSet_Score&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Ensure that the required data exists in .obsm</span>
    <span class="k">if</span> <span class="s1">&#39;X_pca&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;X_pca not found in .obsm. Perform PCA before combining.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">score_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">score_key</span><span class="si">}</span><span class="s2"> not found in .obsm. Please provide valid gene set scores.&quot;</span><span class="p">)</span>

    <span class="c1"># Extract the top n_pcs from .obsm[&#39;X_pca&#39;]</span>
    <span class="n">pca_matrix</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s1">&#39;X_pca&#39;</span><span class="p">][:,</span> <span class="p">:</span><span class="n">n_pcs</span><span class="p">]</span>

    <span class="c1"># Extract the gene set scores from .obsm</span>
    <span class="n">score_matrix</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="n">score_key</span><span class="p">]</span>

    <span class="c1"># Combine PCA matrix and score matrix horizontally (along columns)</span>
    <span class="n">combined_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">pca_matrix</span><span class="p">,</span> <span class="n">score_matrix</span><span class="p">])</span>

    <span class="c1"># Add the combined matrix back into .obsm with a new key</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s1">&#39;X_pca_scores_combined&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">combined_matrix</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Combined matrix with </span><span class="si">{</span><span class="n">n_pcs</span><span class="si">}</span><span class="s2"> PCs and </span><span class="si">{</span><span class="n">score_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> gene set scores added to .obsm[&#39;X_pca_scores_combined&#39;].&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.utils.create_gene_structure_dict_by_stage" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">create_gene_structure_dict_by_stage</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">create_gene_structure_dict_by_stage</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">stage</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Create a dictionary mapping structures to lists of genes expressed at a specific stage. Designed for parsing output from Jax Labs MGI data</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>file_path</code></b>
              (<code>str</code>)
          –
          <div class="doc-md-description">
            <p>Path to the gene expression file.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>stage</code></b>
              (<code>str or int</code>)
          –
          <div class="doc-md-description">
            <p>The Theiler Stage to filter the data.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
<b><code>dict</code></b>          –
          <div class="doc-md-description">
            <p>A dictionary where keys are structures and values are lists of genes expressed in those structures.</p>
          </div>
        </li>
    </ul>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/utils/annotation.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">create_gene_structure_dict_by_stage</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">stage</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a dictionary mapping structures to lists of genes expressed at a specific stage. Designed for parsing output from Jax Labs MGI data</span>

<span class="sd">    Parameters:</span>
<span class="sd">        file_path (str): Path to the gene expression file.</span>
<span class="sd">        stage (str or int): The Theiler Stage to filter the data.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: A dictionary where keys are structures and values are lists of genes expressed in those structures.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">structure_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>  <span class="c1"># Using a set to avoid duplicate gene symbols</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
        <span class="n">reader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">DictReader</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>  <span class="c1"># Use tab-delimiter based on previous example</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Theiler Stage&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">stage</span><span class="p">):</span>  <span class="c1"># Subset by stage</span>
                <span class="n">structure</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Structure&#39;</span><span class="p">]</span>
                <span class="n">gene_symbol</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Gene Symbol&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">structure</span> <span class="ow">and</span> <span class="n">gene_symbol</span><span class="p">:</span>  <span class="c1"># Ensure both fields are not empty</span>
                    <span class="n">structure_dict</span><span class="p">[</span><span class="n">structure</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">gene_symbol</span><span class="p">)</span>

    <span class="c1"># Convert sets to lists for final output</span>
    <span class="n">structure_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">structure</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">genes</span><span class="p">)</span> <span class="k">for</span> <span class="n">structure</span><span class="p">,</span> <span class="n">genes</span> <span class="ow">in</span> <span class="n">structure_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">return</span> <span class="n">structure_dict</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.utils.extract_top_bottom_genes" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">extract_top_bottom_genes</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">extract_top_bottom_genes</span><span class="p">(</span><span class="n">deg_res</span><span class="p">,</span> <span class="n">ngenes</span><span class="p">,</span> <span class="n">sort_by</span><span class="o">=</span><span class="s1">&#39;scores&#39;</span><span class="p">,</span> <span class="n">extraction_map</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Extracts top and bottom ngenes from each gene table in deg_res and organizes them
into a dictionary with combined keys of group and sample names.</p>
<h5 id="pySingleCellNet.utils.extract_top_bottom_genes--parameters">Parameters:</h5>
<p>deg_res : dict
    A dictionary containing differential expression results with keys:
        - 'sample_names': List of sample names (e.g., ['Singular', 'None'])
        - 'geneTab_dict': Dictionary where each key is a group name and each value is
                          a Pandas DataFrame with gene information.
ngenes : int
    The number of top or bottom genes to extract from each gene table.
sort_by : str, optional (default='scores')
    The column name in the gene tables to sort by.
extraction_map : dict, optional
    A dictionary mapping sample names to extraction behavior ('top' or 'bottom').
    If not provided, defaults to:
        - First sample name: 'top'
        - Second sample name: 'bottom'
        - Additional sample names: 'top'</p>
<h5 id="pySingleCellNet.utils.extract_top_bottom_genes--returns">Returns:</h5>
<p>result_dict : dict
    A dictionary where each key is a combination of group and sample name
    (e.g., 'Meso.Nascent_Singular') and each value is a list of gene names.
    - For 'top', the list contains the top ngenes based on sort_by.
    - For 'bottom', the list contains the bottom ngenes based on sort_by.</p>
<h5 id="pySingleCellNet.utils.extract_top_bottom_genes--raises">Raises:</h5>
<p>KeyError:
    If 'sample_names' or 'geneTab_dict' keys are missing in deg_res,
    or if 'sort_by' is not a column in the gene tables.
ValueError:
    If ngenes is not a positive integer or if 'sample_names' does not contain at least one entry.
TypeError:
    If the input types are incorrect.</p>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/utils/gene.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">extract_top_bottom_genes</span><span class="p">(</span>
    <span class="n">deg_res</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="n">ngenes</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">sort_by</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;scores&#39;</span><span class="p">,</span>
    <span class="n">extraction_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts top and bottom ngenes from each gene table in deg_res and organizes them</span>
<span class="sd">    into a dictionary with combined keys of group and sample names.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    deg_res : dict</span>
<span class="sd">        A dictionary containing differential expression results with keys:</span>
<span class="sd">            - &#39;sample_names&#39;: List of sample names (e.g., [&#39;Singular&#39;, &#39;None&#39;])</span>
<span class="sd">            - &#39;geneTab_dict&#39;: Dictionary where each key is a group name and each value is</span>
<span class="sd">                              a Pandas DataFrame with gene information.</span>
<span class="sd">    ngenes : int</span>
<span class="sd">        The number of top or bottom genes to extract from each gene table.</span>
<span class="sd">    sort_by : str, optional (default=&#39;scores&#39;)</span>
<span class="sd">        The column name in the gene tables to sort by.</span>
<span class="sd">    extraction_map : dict, optional</span>
<span class="sd">        A dictionary mapping sample names to extraction behavior (&#39;top&#39; or &#39;bottom&#39;).</span>
<span class="sd">        If not provided, defaults to:</span>
<span class="sd">            - First sample name: &#39;top&#39;</span>
<span class="sd">            - Second sample name: &#39;bottom&#39;</span>
<span class="sd">            - Additional sample names: &#39;top&#39;</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    result_dict : dict</span>
<span class="sd">        A dictionary where each key is a combination of group and sample name</span>
<span class="sd">        (e.g., &#39;Meso.Nascent_Singular&#39;) and each value is a list of gene names.</span>
<span class="sd">        - For &#39;top&#39;, the list contains the top ngenes based on sort_by.</span>
<span class="sd">        - For &#39;bottom&#39;, the list contains the bottom ngenes based on sort_by.</span>

<span class="sd">    Raises:</span>
<span class="sd">    -------</span>
<span class="sd">    KeyError:</span>
<span class="sd">        If &#39;sample_names&#39; or &#39;geneTab_dict&#39; keys are missing in deg_res,</span>
<span class="sd">        or if &#39;sort_by&#39; is not a column in the gene tables.</span>
<span class="sd">    ValueError:</span>
<span class="sd">        If ngenes is not a positive integer or if &#39;sample_names&#39; does not contain at least one entry.</span>
<span class="sd">    TypeError:</span>
<span class="sd">        If the input types are incorrect.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Input Validation</span>
    <span class="n">required_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;sample_names&#39;</span><span class="p">,</span> <span class="s1">&#39;geneTab_dict&#39;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">required_keys</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">deg_res</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Key &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; not found in deg_res.&quot;</span><span class="p">)</span>

    <span class="n">sample_names</span> <span class="o">=</span> <span class="n">deg_res</span><span class="p">[</span><span class="s1">&#39;sample_names&#39;</span><span class="p">]</span>
    <span class="n">geneTab_dict</span> <span class="o">=</span> <span class="n">deg_res</span><span class="p">[</span><span class="s1">&#39;geneTab_dict&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sample_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;sample_names&#39; should be a list, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">sample_names</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geneTab_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;geneTab_dict&#39; should be a dict, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">geneTab_dict</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ngenes</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ngenes</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;ngenes&#39; must be a positive integer, got </span><span class="si">{</span><span class="n">ngenes</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_names</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;sample_names&#39; should contain at least one entry, got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_names</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="n">result_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Define default extraction behavior if extraction_map is not provided</span>
    <span class="k">if</span> <span class="n">extraction_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">extraction_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">sample</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sample_names</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">extraction_map</span><span class="p">[</span><span class="n">sample</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;top&#39;</span>
            <span class="k">elif</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">extraction_map</span><span class="p">[</span><span class="n">sample</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;bottom&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">extraction_map</span><span class="p">[</span><span class="n">sample</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;top&#39;</span>  <span class="c1"># Default behavior for additional samples</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Validate extraction_map</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">extraction_map</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;extraction_map&#39; should be a dict, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">extraction_map</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sample</span><span class="p">,</span> <span class="n">behavior</span> <span class="ow">in</span> <span class="n">extraction_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">behavior</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid extraction behavior &#39;</span><span class="si">{</span><span class="n">behavior</span><span class="si">}</span><span class="s2">&#39; for sample &#39;</span><span class="si">{</span><span class="n">sample</span><span class="si">}</span><span class="s2">&#39;. Must be &#39;top&#39; or &#39;bottom&#39;.&quot;</span><span class="p">)</span>

    <span class="c1"># Iterate over each group in geneTab_dict</span>
    <span class="k">for</span> <span class="n">group</span><span class="p">,</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">geneTab_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected DataFrame for group &#39;</span><span class="si">{</span><span class="n">group</span><span class="si">}</span><span class="s2">&#39;, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="c1"># Ensure required columns exist</span>
        <span class="n">required_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;names&#39;</span><span class="p">,</span> <span class="n">sort_by</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">required_columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column &#39;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">&#39; not found in gene table for group &#39;</span><span class="si">{</span><span class="n">group</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>

        <span class="c1"># Sort the DataFrame by &#39;sort_by&#39; column</span>
        <span class="n">sorted_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="n">sort_by</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Iterate over sample names to determine extraction behavior</span>
        <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">sample_names</span><span class="p">:</span>
            <span class="n">combined_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">group</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">sample</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">behavior</span> <span class="o">=</span> <span class="n">extraction_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="s1">&#39;top&#39;</span><span class="p">)</span>  <span class="c1"># Default to &#39;top&#39; if not specified</span>

            <span class="k">if</span> <span class="n">behavior</span> <span class="o">==</span> <span class="s1">&#39;top&#39;</span><span class="p">:</span>
                <span class="c1"># Extract top ngenes</span>
                <span class="n">top_genes</span> <span class="o">=</span> <span class="n">sorted_df</span><span class="p">[</span><span class="s1">&#39;names&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">ngenes</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">result_dict</span><span class="p">[</span><span class="n">combined_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">top_genes</span>
            <span class="k">elif</span> <span class="n">behavior</span> <span class="o">==</span> <span class="s1">&#39;bottom&#39;</span><span class="p">:</span>
                <span class="c1"># Extract bottom ngenes</span>
                <span class="n">bottom_genes</span> <span class="o">=</span> <span class="n">sorted_df</span><span class="p">[</span><span class="s1">&#39;names&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="n">ngenes</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">result_dict</span><span class="p">[</span><span class="n">combined_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">bottom_genes</span>

    <span class="k">return</span> <span class="n">result_dict</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.utils.filter_adata_by_group_size" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">filter_adata_by_group_size</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">filter_adata_by_group_size</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">groupby</span><span class="p">,</span> <span class="n">ncells</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Filters an AnnData object to retain only cells from groups with at least 'ncells' cells.</p>
<h5 id="pySingleCellNet.utils.filter_adata_by_group_size--parameters">Parameters:</h5>
<p>adata : AnnData
    The input AnnData object containing single-cell data.
groupby : str
    The column name in <code>adata.obs</code> used to define groups (e.g., cluster labels).
ncells : int, optional (default=20)
    The minimum number of cells a group must have to be retained.</p>
<h5 id="pySingleCellNet.utils.filter_adata_by_group_size--returns">Returns:</h5>
<p>filtered_adata : AnnData
    A new AnnData object containing only cells from groups with at least 'ncells' cells.</p>
<h5 id="pySingleCellNet.utils.filter_adata_by_group_size--raises">Raises:</h5>
<p>ValueError:
    - If <code>groupby</code> is not a column in <code>adata.obs</code>.
    - If <code>ncells</code> is not a positive integer.</p>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/utils/cell.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">filter_adata_by_group_size</span><span class="p">(</span><span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span> <span class="n">groupby</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">ncells</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filters an AnnData object to retain only cells from groups with at least &#39;ncells&#39; cells.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    adata : AnnData</span>
<span class="sd">        The input AnnData object containing single-cell data.</span>
<span class="sd">    groupby : str</span>
<span class="sd">        The column name in `adata.obs` used to define groups (e.g., cluster labels).</span>
<span class="sd">    ncells : int, optional (default=20)</span>
<span class="sd">        The minimum number of cells a group must have to be retained.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    filtered_adata : AnnData</span>
<span class="sd">        A new AnnData object containing only cells from groups with at least &#39;ncells&#39; cells.</span>

<span class="sd">    Raises:</span>
<span class="sd">    -------</span>
<span class="sd">    ValueError:</span>
<span class="sd">        - If `groupby` is not a column in `adata.obs`.</span>
<span class="sd">        - If `ncells` is not a positive integer.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Input Validation</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;adata&#39; must be an AnnData object, but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">adata</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">groupby</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;groupby&#39; must be a string, but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">groupby</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">groupby</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">groupby</span><span class="si">}</span><span class="s2">&#39; is not a column in adata.obs. Available columns are: </span><span class="si">{</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ncells</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ncells</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;ncells&#39; must be a positive integer, but got </span><span class="si">{</span><span class="n">ncells</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="c1"># Compute the size of each group</span>
    <span class="n">group_sizes</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">groupby</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>

    <span class="c1"># Identify groups that meet or exceed the minimum cell threshold</span>
    <span class="n">valid_groups</span> <span class="o">=</span> <span class="n">group_sizes</span><span class="p">[</span><span class="n">group_sizes</span> <span class="o">&gt;=</span> <span class="n">ncells</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">valid_groups</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No groups found in &#39;</span><span class="si">{</span><span class="n">groupby</span><span class="si">}</span><span class="s2">&#39; with at least </span><span class="si">{</span><span class="n">ncells</span><span class="si">}</span><span class="s2"> cells.&quot;</span><span class="p">)</span>

    <span class="c1"># Optionally, inform the user about the filtering</span>
    <span class="n">total_groups</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">groupby</span><span class="p">]</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span>
    <span class="n">retained_groups</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_groups</span><span class="p">)</span>
    <span class="n">excluded_groups</span> <span class="o">=</span> <span class="n">total_groups</span> <span class="o">-</span> <span class="n">retained_groups</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filtering AnnData object based on group sizes in &#39;</span><span class="si">{</span><span class="n">groupby</span><span class="si">}</span><span class="s2">&#39;:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; - Total groups: </span><span class="si">{</span><span class="n">total_groups</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; - Groups retained (≥ </span><span class="si">{</span><span class="n">ncells</span><span class="si">}</span><span class="s2"> cells): </span><span class="si">{</span><span class="n">retained_groups</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; - Groups excluded (&lt; </span><span class="si">{</span><span class="n">ncells</span><span class="si">}</span><span class="s2"> cells): </span><span class="si">{</span><span class="n">excluded_groups</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Create a boolean mask for cells belonging to valid groups</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">groupby</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">valid_groups</span><span class="p">)</span>

    <span class="c1"># Apply the mask to filter the AnnData object</span>
    <span class="n">filtered_adata</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Optionally, reset indices if necessary</span>
    <span class="c1"># filtered_adata.obs_names = range(filtered_adata.n_obs)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Filtered AnnData object contains </span><span class="si">{</span><span class="n">filtered_adata</span><span class="o">.</span><span class="n">n_obs</span><span class="si">}</span><span class="s2"> cells from </span><span class="si">{</span><span class="n">filtered_adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">groupby</span><span class="p">]</span><span class="o">.</span><span class="n">nunique</span><span class="p">()</span><span class="si">}</span><span class="s2"> groups.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">filtered_adata</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.utils.filter_anndata_slots" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">filter_anndata_slots</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">filter_anndata_slots</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">slots_to_keep</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Creates a copy of an AnnData object and filters it to retain only the specified 
slots and elements within those slots. Unspecified slots or elements are removed from the copy.</p>
<p>The function operates on a copy of the provided AnnData object, ensuring that the original
data remains unchanged. This approach allows users to maintain data integrity while
exploring different subsets or representations of their dataset.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>adata</code></b>
              (<code>AnnData</code>)
          –
          <div class="doc-md-description">
            <p>The AnnData object to be copied and filtered. This object
represents a single-cell dataset with various annotations and embeddings.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>slots_to_keep</code></b>
              (<code>dict</code>)
          –
          <div class="doc-md-description">
            <p _X_pca_="['X_pca']" _cluster_="['cluster']," _gene_id_="['gene_id']," _obs_:="'obs':" _obsm_:="'obsm':" _var_:="'var':">A dictionary specifying which slots and elements within 
those slots to keep. The keys should be the slot names ('obs', 'var', 'obsm',
'obsp', 'varm', 'varp'), and the values should be lists of the names within 
those slots to preserve. If a slot is not mentioned or its value is None, 
all its contents are removed in the copy. Example format:</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
<b><code>AnnData</code></b>          –
          <div class="doc-md-description">
            <p>A copy of the original AnnData object filtered according to the specified</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
          –
          <div class="doc-md-description">
            <p>slots to keep. This copy contains only the data and annotations specified by the</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
          –
          <div class="doc-md-description">
            <p><code>slots_to_keep</code> dictionary, with all other data and annotations removed.</p>
          </div>
        </li>
    </ul>


<details class="example" open>
  <summary>Example</summary>
  <p>adata = sc.datasets.pbmc68k_reduced()
slots_to_keep = {
    'obs': ['n_genes', 'percent_mito'],
    'var': ['n_cells'],
    # Assuming we want to clear these unless specified to keep
    'obsm': None,
    'obsp': None,
    'varm': None,
    'varp': None,
}
filtered_adata = filter_anndata_slots(adata, slots_to_keep)</p>
<h4 id="pySingleCellNet.utils.filter_anndata_slots--filtered_adata-is-the-modified-copy-adata-remains-unchanged"><code>filtered_adata</code> is the modified copy, <code>adata</code> remains unchanged.</h4>
</details>
            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/utils/adataTools.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">filter_anndata_slots</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">slots_to_keep</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a copy of an AnnData object and filters it to retain only the specified </span>
<span class="sd">    slots and elements within those slots. Unspecified slots or elements are removed from the copy.</span>

<span class="sd">    The function operates on a copy of the provided AnnData object, ensuring that the original</span>
<span class="sd">    data remains unchanged. This approach allows users to maintain data integrity while</span>
<span class="sd">    exploring different subsets or representations of their dataset.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata (AnnData): The AnnData object to be copied and filtered. This object</span>
<span class="sd">            represents a single-cell dataset with various annotations and embeddings.</span>
<span class="sd">        slots_to_keep (dict): A dictionary specifying which slots and elements within </span>
<span class="sd">            those slots to keep. The keys should be the slot names (&#39;obs&#39;, &#39;var&#39;, &#39;obsm&#39;,</span>
<span class="sd">            &#39;obsp&#39;, &#39;varm&#39;, &#39;varp&#39;), and the values should be lists of the names within </span>
<span class="sd">            those slots to preserve. If a slot is not mentioned or its value is None, </span>
<span class="sd">            all its contents are removed in the copy. Example format:</span>
<span class="sd">            {&#39;obs&#39;: [&#39;cluster&#39;], &#39;var&#39;: [&#39;gene_id&#39;], &#39;obsm&#39;: [&#39;X_pca&#39;]}</span>

<span class="sd">    Returns:</span>
<span class="sd">        AnnData: A copy of the original AnnData object filtered according to the specified</span>
<span class="sd">        slots to keep. This copy contains only the data and annotations specified by the</span>
<span class="sd">        `slots_to_keep` dictionary, with all other data and annotations removed.</span>

<span class="sd">    Example:</span>
<span class="sd">        adata = sc.datasets.pbmc68k_reduced()</span>
<span class="sd">        slots_to_keep = {</span>
<span class="sd">            &#39;obs&#39;: [&#39;n_genes&#39;, &#39;percent_mito&#39;],</span>
<span class="sd">            &#39;var&#39;: [&#39;n_cells&#39;],</span>
<span class="sd">            # Assuming we want to clear these unless specified to keep</span>
<span class="sd">            &#39;obsm&#39;: None,</span>
<span class="sd">            &#39;obsp&#39;: None,</span>
<span class="sd">            &#39;varm&#39;: None,</span>
<span class="sd">            &#39;varp&#39;: None,</span>
<span class="sd">        }</span>
<span class="sd">        filtered_adata = filter_anndata_slots(adata, slots_to_keep)</span>
<span class="sd">        # `filtered_adata` is the modified copy, `adata` remains unchanged.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Create a copy of the AnnData object to work on</span>
    <span class="n">adata_copy</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Define all possible slots</span>
    <span class="n">all_slots</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;obs&#39;</span><span class="p">,</span> <span class="s1">&#39;var&#39;</span><span class="p">,</span> <span class="s1">&#39;obsm&#39;</span><span class="p">,</span> <span class="s1">&#39;obsp&#39;</span><span class="p">,</span> <span class="s1">&#39;varm&#39;</span><span class="p">,</span> <span class="s1">&#39;varp&#39;</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">slot</span> <span class="ow">in</span> <span class="n">all_slots</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">slot</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">slots_to_keep</span> <span class="ow">or</span> <span class="n">slots_to_keep</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If slot is not mentioned or is None, remove all its contents</span>
            <span class="k">if</span> <span class="n">slot</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;obs&#39;</span><span class="p">,</span> <span class="s1">&#39;var&#39;</span><span class="p">]:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">adata_copy</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">adata_copy</span><span class="p">,</span> <span class="n">slot</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">adata_copy</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="p">{})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Specific elements within the slot are specified to be kept</span>
            <span class="n">elements_to_keep</span> <span class="o">=</span> <span class="n">slots_to_keep</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">slot</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;obs&#39;</span><span class="p">,</span> <span class="s1">&#39;var&#39;</span><span class="p">]:</span>
                <span class="c1"># Filter columns for &#39;obs&#39; and &#39;var&#39;</span>
                <span class="n">df</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">adata_copy</span><span class="p">,</span> <span class="n">slot</span><span class="p">)</span>
                <span class="n">columns_to_drop</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">elements_to_keep</span><span class="p">]</span>
                <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns_to_drop</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">slot</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;obsm&#39;</span><span class="p">,</span> <span class="s1">&#39;obsp&#39;</span><span class="p">,</span> <span class="s1">&#39;varm&#39;</span><span class="p">,</span> <span class="s1">&#39;varp&#39;</span><span class="p">]:</span>
                <span class="c1"># Filter keys for &#39;obsm&#39;, &#39;obsp&#39;, &#39;varm&#39;, &#39;varp&#39;</span>
                <span class="n">mapping</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">adata_copy</span><span class="p">,</span> <span class="n">slot</span><span class="p">)</span>
                <span class="n">keys_to_drop</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">elements_to_keep</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys_to_drop</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">adata_copy</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.utils.filter_gene_list" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">filter_gene_list</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">filter_gene_list</span><span class="p">(</span><span class="n">genelist</span><span class="p">,</span> <span class="n">min_genes</span><span class="p">,</span> <span class="n">max_genes</span><span class="o">=</span><span class="mf">1000000.0</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Filter the gene lists in the provided dictionary based on their lengths.</p>
        <ul>
<li>genelist : dict
    Dictionary with keys as identifiers and values as lists of genes.</li>
<li>min_genes : int
    Minimum number of genes a list should have.</li>
<li>max_genes : int
    Maximum number of genes a list should have.</li>
</ul>
        <ul>
<li>dict
    Filtered dictionary with lists that have a length between min_genes and max_genes (inclusive of min_genes and max_genes).</li>
</ul>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/utils/annotation.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">filter_gene_list</span><span class="p">(</span><span class="n">genelist</span><span class="p">,</span> <span class="n">min_genes</span><span class="p">,</span> <span class="n">max_genes</span><span class="o">=</span><span class="mf">1e6</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter the gene lists in the provided dictionary based on their lengths.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - genelist : dict</span>
<span class="sd">        Dictionary with keys as identifiers and values as lists of genes.</span>
<span class="sd">    - min_genes : int</span>
<span class="sd">        Minimum number of genes a list should have.</span>
<span class="sd">    - max_genes : int</span>
<span class="sd">        Maximum number of genes a list should have.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - dict</span>
<span class="sd">        Filtered dictionary with lists that have a length between min_genes and max_genes (inclusive of min_genes and max_genes).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filtered_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">genelist</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">min_genes</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_genes</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">filtered_dict</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.utils.find_elbow" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">find_elbow</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">find_elbow</span><span class="p">(</span><span class="n">adata</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Find the "elbow" index in the variance explained by principal components.</p>
        <ul>
<li>variance_explained : list or array
    Variance explained by each principal component, typically in decreasing order.</li>
</ul>
        <ul>
<li>int
    The index corresponding to the "elbow" in the variance explained plot.</li>
</ul>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/utils/adataTools.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">find_elbow</span><span class="p">(</span>
    <span class="n">adata</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the &quot;elbow&quot; index in the variance explained by principal components.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - variance_explained : list or array</span>
<span class="sd">        Variance explained by each principal component, typically in decreasing order.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - int</span>
<span class="sd">        The index corresponding to the &quot;elbow&quot; in the variance explained plot.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">variance_explained</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s1">&#39;pca&#39;</span><span class="p">][</span><span class="s1">&#39;variance_ratio&#39;</span><span class="p">]</span>
    <span class="c1"># Coordinates of all points</span>
    <span class="n">n_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">variance_explained</span><span class="p">)</span>
    <span class="n">all_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="nb">range</span><span class="p">(</span><span class="n">n_points</span><span class="p">),</span> <span class="n">variance_explained</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># Line vector from first to last point</span>
    <span class="n">line_vec</span> <span class="o">=</span> <span class="n">all_coords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">all_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">line_vec_norm</span> <span class="o">=</span> <span class="n">line_vec</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">line_vec</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    <span class="c1"># Vector being orthogonal to the line</span>
    <span class="n">vec_from_first</span> <span class="o">=</span> <span class="n">all_coords</span> <span class="o">-</span> <span class="n">all_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">scalar_prod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vec_from_first</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">line_vec_norm</span><span class="p">,</span> <span class="p">(</span><span class="n">n_points</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">vec_from_first_parallel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">scalar_prod</span><span class="p">,</span> <span class="n">line_vec_norm</span><span class="p">)</span>
    <span class="n">vec_to_line</span> <span class="o">=</span> <span class="n">vec_from_first</span> <span class="o">-</span> <span class="n">vec_from_first_parallel</span>
    <span class="c1"># Distance to the line</span>
    <span class="n">dist_to_line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vec_to_line</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1"># Index of the point with max distance to the line</span>
    <span class="n">elbow_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">dist_to_line</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">elbow_idx</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.utils.find_knee_point" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">find_knee_point</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">find_knee_point</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">total_counts_column</span><span class="o">=</span><span class="s1">&#39;total_counts&#39;</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Identifies the knee point of the UMI count distribution in an AnnData object.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>adata</code></b>
              (<code><span title="anndata.AnnData">AnnData</span></code>)
          –
          <div class="doc-md-description">
            <p>The input AnnData object.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>total_counts_column</code></b>
              (<code>str</code>, default:
                  <code>&#39;total_counts&#39;</code>
)
          –
          <div class="doc-md-description">
            <p>Column in <code>adata.obs</code> containing total UMI counts. Default is "total_counts".</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>show</code></b>
              (<code>bool</code>)
          –
          <div class="doc-md-description">
            <p>If True, displays a log-log plot with the knee point. Default is True.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
<b><code>float</code></b>          –
          <div class="doc-md-description">
            <p>The UMI count value at the knee point.</p>
          </div>
        </li>
    </ul>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/utils/qc.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">find_knee_point</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">total_counts_column</span><span class="o">=</span><span class="s2">&quot;total_counts&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies the knee point of the UMI count distribution in an AnnData object.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        adata (AnnData): The input AnnData object.</span>
<span class="sd">        total_counts_column (str): Column in `adata.obs` containing total UMI counts. Default is &quot;total_counts&quot;.</span>
<span class="sd">        show (bool): If True, displays a log-log plot with the knee point. Default is True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: The UMI count value at the knee point.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extract total UMI counts</span>
    <span class="n">umi_counts</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">total_counts_column</span><span class="p">]</span>

    <span class="c1"># Sort UMI counts in descending order</span>
    <span class="n">sorted_umi_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">umi_counts</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Compute cumulative UMI counts (normalized to a fraction)</span>
    <span class="n">cumulative_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">sorted_umi_counts</span><span class="p">)</span>
    <span class="n">cumulative_fraction</span> <span class="o">=</span> <span class="n">cumulative_counts</span> <span class="o">/</span> <span class="n">cumulative_counts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Compute derivatives to identify the knee point</span>
    <span class="n">first_derivative</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">cumulative_fraction</span><span class="p">)</span>
    <span class="n">second_derivative</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">first_derivative</span><span class="p">)</span>

    <span class="c1"># Find the index of the maximum curvature (knee point)</span>
    <span class="n">knee_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">second_derivative</span><span class="p">)</span>
    <span class="n">knee_point_value</span> <span class="o">=</span> <span class="n">sorted_umi_counts</span><span class="p">[</span><span class="n">knee_idx</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">knee_point_value</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.utils.generate_joint_graph" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">generate_joint_graph</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">generate_joint_graph</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">connectivity_keys</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">output_key</span><span class="o">=</span><span class="s1">&#39;jointNeighbors&#39;</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Create a joint graph by combining multiple connectivity graphs with specified weights.</p>
<p>This function computes the weighted sum of selected connectivity and distance matrices 
in an AnnData object and stores the result in <code>.obsp</code>.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>adata</code></b>
              (<code>AnnData</code>)
          –
          <div class="doc-md-description">
            <p>The AnnData object containing connectivity matrices in <code>.obsp</code>.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>connectivity_keys</code></b>
              (<code>list of str</code>)
          –
          <div class="doc-md-description">
            <p>A list of keys in <code>adata.obsp</code> corresponding to connectivity matrices to combine.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>weights</code></b>
              (<code>list of float</code>)
          –
          <div class="doc-md-description">
            <p>A list of weights for each connectivity matrix. Must match the length of <code>connectivity_keys</code>.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>output_key</code></b>
              (<code>str</code>, default:
                  <code>&#39;jointNeighbors&#39;</code>
)
          –
          <div class="doc-md-description">
            <p>The base key under which to store the combined graph in <code>.obsp</code>. 
The default is <code>'jointNeighbors'</code>.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>ValueError</code>
            –
          <div class="doc-md-description">
            <p>If the number of <code>connectivity_keys</code> does not match the number of <code>weights</code>.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code>KeyError</code>
            –
          <div class="doc-md-description">
            <p>If any key in <code>connectivity_keys</code> or its corresponding distances key is not found in <code>adata.obsp</code>.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
<b><code>None</code></b>          –
          <div class="doc-md-description">
            <p>Updates the AnnData object in place by adding the combined connectivity and distance matrices
to <code>.obsp</code> and metadata to <code>.uns</code>.</p>
          </div>
        </li>
    </ul>


<details class="example" open>
  <summary>Example</summary>
  <blockquote>
<blockquote>
<blockquote>
<p>generate_joint_graph(adata, ['neighbors_connectivities', 'umap_connectivities'], [0.7, 0.3])
adata.obsp['jointNeighbors_connectivities']
adata.uns['jointNeighbors']</p>
</blockquote>
</blockquote>
</blockquote>
</details>
            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/utils/adataTools.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">generate_joint_graph</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">connectivity_keys</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">output_key</span><span class="o">=</span><span class="s1">&#39;jointNeighbors&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a joint graph by combining multiple connectivity graphs with specified weights.</span>

<span class="sd">    This function computes the weighted sum of selected connectivity and distance matrices </span>
<span class="sd">    in an AnnData object and stores the result in `.obsp`.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata (AnnData): </span>
<span class="sd">            The AnnData object containing connectivity matrices in `.obsp`.</span>
<span class="sd">        connectivity_keys (list of str): </span>
<span class="sd">            A list of keys in `adata.obsp` corresponding to connectivity matrices to combine.</span>
<span class="sd">        weights (list of float): </span>
<span class="sd">            A list of weights for each connectivity matrix. Must match the length of `connectivity_keys`.</span>
<span class="sd">        output_key (str, optional): </span>
<span class="sd">            The base key under which to store the combined graph in `.obsp`. </span>
<span class="sd">            The default is `&#39;jointNeighbors&#39;`.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the number of `connectivity_keys` does not match the number of `weights`.</span>
<span class="sd">        KeyError: If any key in `connectivity_keys` or its corresponding distances key is not found in `adata.obsp`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: </span>
<span class="sd">            Updates the AnnData object in place by adding the combined connectivity and distance matrices</span>
<span class="sd">            to `.obsp` and metadata to `.uns`.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; generate_joint_graph(adata, [&#39;neighbors_connectivities&#39;, &#39;umap_connectivities&#39;], [0.7, 0.3])</span>
<span class="sd">        &gt;&gt;&gt; adata.obsp[&#39;jointNeighbors_connectivities&#39;]</span>
<span class="sd">        &gt;&gt;&gt; adata.uns[&#39;jointNeighbors&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">connectivity_keys</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of connectivity keys must match the number of weights.&quot;</span><span class="p">)</span>

    <span class="c1"># Initialize the joint graph and distances matrix with zeros</span>
    <span class="n">joint_graph</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">joint_distances</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># Loop through each connectivity key and weight</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">connectivity_keys</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; not found in adata.obsp.&quot;</span><span class="p">)</span>

        <span class="c1"># Retrieve the connectivity matrix</span>
        <span class="n">connectivity_matrix</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="c1"># Assume corresponding distances key exists</span>
        <span class="n">distances_key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;connectivities&#39;</span><span class="p">,</span> <span class="s1">&#39;distances&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">distances_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">distances_key</span><span class="si">}</span><span class="s2">&#39; not found in adata.obsp.&quot;</span><span class="p">)</span>
        <span class="n">distances_matrix</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">[</span><span class="n">distances_key</span><span class="p">]</span>
        <span class="c1"># Initialize or accumulate the weighted connectivity and distances matrices</span>
        <span class="k">if</span> <span class="n">joint_graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">joint_graph</span> <span class="o">=</span> <span class="n">weight</span> <span class="o">*</span> <span class="n">connectivity_matrix</span>
            <span class="n">joint_distances</span> <span class="o">=</span> <span class="n">weight</span> <span class="o">*</span> <span class="n">distances_matrix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">joint_graph</span> <span class="o">+=</span> <span class="n">weight</span> <span class="o">*</span> <span class="n">connectivity_matrix</span>
            <span class="n">joint_distances</span> <span class="o">+=</span> <span class="n">weight</span> <span class="o">*</span> <span class="n">distances_matrix</span>

    <span class="c1"># Save the resulting joint graph and distances matrix in the specified keys of .obsp</span>

    <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">[</span><span class="n">output_key</span> <span class="o">+</span> <span class="s1">&#39;_connectivities&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">joint_graph</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">[</span><span class="n">output_key</span> <span class="o">+</span> <span class="s1">&#39;_distances&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">joint_distances</span>

    <span class="c1"># Save metadata about the joint graph in .uns</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="n">output_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;connectivities_key&#39;</span><span class="p">:</span> <span class="n">output_key</span> <span class="o">+</span> <span class="s1">&#39;_connectivities&#39;</span><span class="p">,</span>
        <span class="s1">&#39;distances_key&#39;</span><span class="p">:</span> <span class="n">output_key</span> <span class="o">+</span> <span class="s1">&#39;_distances&#39;</span><span class="p">,</span>
        <span class="s1">&#39;params&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;connectivity_keys&#39;</span><span class="p">:</span> <span class="n">connectivity_keys</span><span class="p">,</span>
            <span class="s1">&#39;weights&#39;</span><span class="p">:</span> <span class="n">weights</span><span class="p">,</span>
            <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="s2">&quot;umap&quot;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.utils.get_unique_colors" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">get_unique_colors</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">get_unique_colors</span><span class="p">(</span><span class="n">n_colors</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Generate a list of unique colors from the Tab20, Tab20b, and Tab20c colormaps.</p>
<p>Parameters:
- n_colors: The number of unique colors needed.</p>
<p>Returns:
- A list of unique colors.</p>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/utils/colors.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_unique_colors</span><span class="p">(</span><span class="n">n_colors</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a list of unique colors from the Tab20, Tab20b, and Tab20c colormaps.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - n_colors: The number of unique colors needed.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - A list of unique colors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the colormaps</span>
    <span class="n">tab20</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;tab20&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">colors</span>
    <span class="n">tab20b</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;tab20b&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">colors</span>
    <span class="n">tab20c</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;tab20c&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">colors</span>

    <span class="c1"># Combine the colors from the colormaps</span>
    <span class="n">combined_colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">tab20</span><span class="p">,</span> <span class="n">tab20b</span><span class="p">,</span> <span class="n">tab20c</span><span class="p">])</span>

    <span class="c1"># Check if the requested number of colors exceeds the available unique colors</span>
    <span class="k">if</span> <span class="n">n_colors</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">combined_colors</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Requested number of colors (</span><span class="si">{</span><span class="n">n_colors</span><span class="si">}</span><span class="s2">) exceeds the available unique colors (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">combined_colors</span><span class="p">)</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>

    <span class="c1"># Select the required number of unique colors</span>
    <span class="n">selected_colors</span> <span class="o">=</span> <span class="n">combined_colors</span><span class="p">[:</span><span class="n">n_colors</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">selected_colors</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.utils.mito_rib" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">mito_rib</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">mito_rib</span><span class="p">(</span><span class="n">adQ</span><span class="p">,</span> <span class="n">species</span><span class="o">=</span><span class="s1">&#39;MM&#39;</span><span class="p">,</span> <span class="n">log1p</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Calculate mitochondrial and ribosomal QC metrics and add them to the <code>.var</code> attribute of the AnnData object.</p>
<h5 id="pySingleCellNet.utils.mito_rib--parameters">Parameters</h5>
<p>adQ : AnnData
    Annotated data matrix with observations (cells) and variables (features).
species : str, optional (default: "MM")
    The species of the input data. Can be "MM" (Mus musculus) or "HS" (Homo sapiens).
clean : bool, optional (default: True)
    Whether to remove mitochondrial and ribosomal genes from the data.</p>
<h5 id="pySingleCellNet.utils.mito_rib--returns">Returns</h5>
<p>AnnData
    Annotated data matrix with QC metrics added to the <code>.var</code> attribute.</p>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/utils/qc.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">mito_rib</span><span class="p">(</span><span class="n">adQ</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span> <span class="n">species</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;MM&quot;</span><span class="p">,</span> <span class="n">log1p</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">clean</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnnData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate mitochondrial and ribosomal QC metrics and add them to the `.var` attribute of the AnnData object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adQ : AnnData</span>
<span class="sd">        Annotated data matrix with observations (cells) and variables (features).</span>
<span class="sd">    species : str, optional (default: &quot;MM&quot;)</span>
<span class="sd">        The species of the input data. Can be &quot;MM&quot; (Mus musculus) or &quot;HS&quot; (Homo sapiens).</span>
<span class="sd">    clean : bool, optional (default: True)</span>
<span class="sd">        Whether to remove mitochondrial and ribosomal genes from the data.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    AnnData</span>
<span class="sd">        Annotated data matrix with QC metrics added to the `.var` attribute.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create a copy of the input data</span>
    <span class="n">adata</span> <span class="o">=</span> <span class="n">adQ</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Define mitochondrial and ribosomal gene prefixes based on the species</span>
    <span class="k">if</span> <span class="n">species</span> <span class="o">==</span> <span class="s1">&#39;MM&#39;</span><span class="p">:</span>
        <span class="n">mt_prefix</span> <span class="o">=</span> <span class="s2">&quot;mt-&quot;</span>
        <span class="n">ribo_prefix</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Rps&quot;</span><span class="p">,</span><span class="s2">&quot;Rpl&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mt_prefix</span> <span class="o">=</span> <span class="s2">&quot;MT-&quot;</span>
        <span class="n">ribo_prefix</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;RPS&quot;</span><span class="p">,</span><span class="s2">&quot;RPL&quot;</span><span class="p">)</span>

    <span class="c1"># Add mitochondrial and ribosomal gene flags to the `.var` attribute</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;mt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">startswith</span><span class="p">((</span><span class="n">mt_prefix</span><span class="p">))</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;ribo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">ribo_prefix</span><span class="p">)</span>

    <span class="c1"># Calculate QC metrics using Scanpy&#39;s `calculate_qc_metrics` function</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">calculate_qc_metrics</span><span class="p">(</span>
        <span class="n">adata</span><span class="p">,</span>
        <span class="n">qc_vars</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ribo&#39;</span><span class="p">,</span> <span class="s1">&#39;mt&#39;</span><span class="p">],</span>
        <span class="n">percent_top</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">log1p</span><span class="o">=</span><span class="n">log1p</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>

    <span class="c1"># Optionally remove mitochondrial and ribosomal genes from the data</span>
    <span class="k">if</span> <span class="n">clean</span><span class="p">:</span>
        <span class="n">mito_genes</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">mt_prefix</span><span class="p">)</span>
        <span class="n">ribo_genes</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">ribo_prefix</span><span class="p">)</span>
        <span class="n">remove</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">mito_genes</span><span class="p">,</span> <span class="n">ribo_genes</span><span class="p">)</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">remove</span><span class="p">)</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[:,</span><span class="n">keep</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># sc.pp.calculate_qc_metrics(adata,percent_top=None,log1p=False,inplace=True)</span>

    <span class="k">return</span> <span class="n">adata</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.utils.mito_rib_heme" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">mito_rib_heme</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">mito_rib_heme</span><span class="p">(</span><span class="n">adQ</span><span class="p">,</span> <span class="n">species</span><span class="o">=</span><span class="s1">&#39;MM&#39;</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Calculate mitochondrial, ribosomal, and hemoglobin QC metrics 
and add them to the <code>.var</code> attribute of the AnnData object.</p>
<h5 id="pySingleCellNet.utils.mito_rib_heme--parameters">Parameters</h5>
<p>adQ : AnnData
    Annotated data matrix with observations (cells) and variables (features).
species : str, optional (default: "MM")
    The species of the input data. Can be "MM" (Mus musculus) or "HS" (Homo sapiens).
clean : dict, optional (default: {'ribo': True, 'mt': True, 'heme': True})
    Dictionary controlling whether to remove:
      - 'ribo': ribosomal genes
      - 'mt': mitochondrial genes
      - 'heme': hemoglobin genes</p>
<h5 id="pySingleCellNet.utils.mito_rib_heme--returns">Returns</h5>
<p>AnnData
    Annotated data matrix with QC metrics added to the <code>.var</code> attribute,
    and optionally with certain gene classes removed.</p>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/utils/qc.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">mito_rib_heme</span><span class="p">(</span><span class="n">adQ</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
                  <span class="n">species</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;MM&quot;</span><span class="p">,</span>
                  <span class="n">clean</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnnData</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate mitochondrial, ribosomal, and hemoglobin QC metrics </span>
<span class="sd">    and add them to the `.var` attribute of the AnnData object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adQ : AnnData</span>
<span class="sd">        Annotated data matrix with observations (cells) and variables (features).</span>
<span class="sd">    species : str, optional (default: &quot;MM&quot;)</span>
<span class="sd">        The species of the input data. Can be &quot;MM&quot; (Mus musculus) or &quot;HS&quot; (Homo sapiens).</span>
<span class="sd">    clean : dict, optional (default: {&#39;ribo&#39;: True, &#39;mt&#39;: True, &#39;heme&#39;: True})</span>
<span class="sd">        Dictionary controlling whether to remove:</span>
<span class="sd">          - &#39;ribo&#39;: ribosomal genes</span>
<span class="sd">          - &#39;mt&#39;: mitochondrial genes</span>
<span class="sd">          - &#39;heme&#39;: hemoglobin genes</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    AnnData</span>
<span class="sd">        Annotated data matrix with QC metrics added to the `.var` attribute,</span>
<span class="sd">        and optionally with certain gene classes removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># -------------------------</span>
    <span class="c1"># 1. Set default if clean is None</span>
    <span class="c1"># -------------------------</span>
    <span class="k">if</span> <span class="n">clean</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">clean</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ribo&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;mt&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;heme&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Ensure all three keys exist; if not, set them to default True</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ribo&#39;</span><span class="p">,</span> <span class="s1">&#39;mt&#39;</span><span class="p">,</span> <span class="s1">&#39;heme&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">clean</span><span class="p">:</span>
                <span class="n">clean</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># -------------------------</span>
    <span class="c1"># 2. Copy the input data</span>
    <span class="c1"># -------------------------</span>
    <span class="n">adata</span> <span class="o">=</span> <span class="n">adQ</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># -------------------------</span>
    <span class="c1"># 3. Define gene prefixes based on species</span>
    <span class="c1"># -------------------------</span>
    <span class="k">if</span> <span class="n">species</span> <span class="o">==</span> <span class="s1">&#39;MM&#39;</span><span class="p">:</span>
        <span class="c1"># MOUSE</span>
        <span class="n">mt_prefix</span> <span class="o">=</span> <span class="s2">&quot;mt-&quot;</span>
        <span class="n">ribo_prefix</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Rps&quot;</span><span class="p">,</span> <span class="s2">&quot;Rpl&quot;</span><span class="p">)</span>
        <span class="c1"># Common mouse hemoglobin genes often start with &#39;Hba-&#39; or &#39;Hbb-&#39;</span>
        <span class="n">heme_prefix</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Hba-&quot;</span><span class="p">,</span> <span class="s2">&quot;Hbb-&quot;</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># HUMAN</span>
        <span class="n">mt_prefix</span> <span class="o">=</span> <span class="s2">&quot;MT-&quot;</span>
        <span class="n">ribo_prefix</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;RPS&quot;</span><span class="p">,</span> <span class="s2">&quot;RPL&quot;</span><span class="p">)</span>
        <span class="c1"># Human hemoglobin genes typically start with &#39;HB...&#39; </span>
        <span class="c1"># (HBA, HBB, HBD, HBE, HBG, HBZ, HBM, HBQ, etc.)</span>
        <span class="c1"># Using just &quot;HB&quot; can be too broad in some annotations, </span>
        <span class="c1"># so here&#39;s a more explicit tuple:</span>
        <span class="n">heme_prefix</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;HBA&quot;</span><span class="p">,</span> <span class="s2">&quot;HBB&quot;</span><span class="p">,</span> <span class="s2">&quot;HBD&quot;</span><span class="p">,</span> <span class="s2">&quot;HBE&quot;</span><span class="p">,</span> <span class="s2">&quot;HBG&quot;</span><span class="p">,</span> <span class="s2">&quot;HBZ&quot;</span><span class="p">,</span> <span class="s2">&quot;HBM&quot;</span><span class="p">,</span> <span class="s2">&quot;HBQ&quot;</span><span class="p">)</span>

    <span class="c1"># -------------------------</span>
    <span class="c1"># 4. Flag MT, Ribo, and Heme genes in .var</span>
    <span class="c1"># -------------------------</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;mt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">mt_prefix</span><span class="p">)</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;ribo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">ribo_prefix</span><span class="p">)</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;heme&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">heme_prefix</span><span class="p">)</span>

    <span class="c1"># -------------------------</span>
    <span class="c1"># 5. Calculate QC metrics </span>
    <span class="c1">#    (Scanpy automatically calculates .var[&#39;total_counts&#39;] etc.)</span>
    <span class="c1"># -------------------------</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">calculate_qc_metrics</span><span class="p">(</span>
        <span class="n">adata</span><span class="p">,</span>
        <span class="n">qc_vars</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;ribo&#39;</span><span class="p">,</span> <span class="s1">&#39;mt&#39;</span><span class="p">,</span> <span class="s1">&#39;heme&#39;</span><span class="p">],</span>
        <span class="n">percent_top</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">log1p</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>

    <span class="c1"># -------------------------</span>
    <span class="c1"># 6. Optionally remove genes</span>
    <span class="c1"># -------------------------</span>
    <span class="n">remove_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">clean</span><span class="p">[</span><span class="s1">&#39;mt&#39;</span><span class="p">]:</span>
        <span class="n">remove_mask</span> <span class="o">|=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;mt&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="k">if</span> <span class="n">clean</span><span class="p">[</span><span class="s1">&#39;ribo&#39;</span><span class="p">]:</span>
        <span class="n">remove_mask</span> <span class="o">|=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;ribo&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="k">if</span> <span class="n">clean</span><span class="p">[</span><span class="s1">&#39;heme&#39;</span><span class="p">]:</span>
        <span class="n">remove_mask</span> <span class="o">|=</span> <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;heme&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

    <span class="n">keep_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">remove_mask</span>

    <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[:,</span> <span class="n">keep_mask</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># -------------------------</span>
    <span class="c1"># 7. Return the modified AnnData</span>
    <span class="c1"># -------------------------</span>
    <span class="k">return</span> <span class="n">adata</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.utils.rank_genes_subsets" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">rank_genes_subsets</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">rank_genes_subsets</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">groupby</span><span class="p">,</span> <span class="n">grpA</span><span class="p">,</span> <span class="n">grpB</span><span class="p">,</span> <span class="n">pval</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Subset an AnnData object to specified groups, create a new .obs column labeling cells
as group A or B, and run rank_genes_groups for differential expression analysis. Necessary because the scanpy reference does not seem to work</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>adata</code></b>
              (<code><span title="anndata.AnnData">AnnData</span></code>)
          –
          <div class="doc-md-description">
            <p>The AnnData object.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>groupby</code></b>
              (<code>str</code>)
          –
          <div class="doc-md-description">
            <p>The .obs column to group cells by.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>grpA</code></b>
              (<code>list</code>)
          –
          <div class="doc-md-description">
            <p>Values used to subset cells into group A.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>grpB</code></b>
              (<code>list</code>)
          –
          <div class="doc-md-description">
            <p>Values used to subset cells into group B.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>layer</code></b>
              (<code>str</code>, default:
                  <code>None</code>
)
          –
          <div class="doc-md-description">
            <p>Layer to use for expression values.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
<b><code>AnnData</code></b>          –
          <div class="doc-md-description">
            <p>Subsetted and labeled AnnData object after running rank_genes_groups.</p>
          </div>
        </li>
    </ul>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/utils/gene.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">rank_genes_subsets</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">,</span>
    <span class="n">groupby</span><span class="p">,</span>
    <span class="n">grpA</span><span class="p">,</span>
    <span class="n">grpB</span><span class="p">,</span>
    <span class="n">pval</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
    <span class="n">layer</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Subset an AnnData object to specified groups, create a new .obs column labeling cells</span>
<span class="sd">    as group A or B, and run rank_genes_groups for differential expression analysis. Necessary because the scanpy reference does not seem to work</span>

<span class="sd">    Parameters:</span>
<span class="sd">        adata (AnnData): The AnnData object.</span>
<span class="sd">        groupby (str): The .obs column to group cells by.</span>
<span class="sd">        grpA (list): Values used to subset cells into group A.</span>
<span class="sd">        grpB (list): Values used to subset cells into group B.</span>
<span class="sd">        layer (str, optional): Layer to use for expression values.</span>

<span class="sd">    Returns:</span>
<span class="sd">        AnnData: Subsetted and labeled AnnData object after running rank_genes_groups.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Subset the data to cells in either grpA or grpB</span>
    <span class="n">subset</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">groupby</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">grpA</span> <span class="o">+</span> <span class="n">grpB</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># Create a new .obs column labeling cells as &#39;grpA&#39; or &#39;grpB&#39;</span>
    <span class="n">subset</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s2">&quot;comparison_group&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">subset</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">groupby</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;grpA&quot;</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">grpA</span> <span class="k">else</span> <span class="s2">&quot;grpB&quot;</span>
    <span class="p">)</span>
    <span class="c1"># Run rank_genes_groups</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">rank_genes_groups</span><span class="p">(</span>
        <span class="n">subset</span><span class="p">,</span>
        <span class="n">groupby</span><span class="o">=</span><span class="s2">&quot;comparison_group&quot;</span><span class="p">,</span>
        <span class="n">layer</span><span class="o">=</span><span class="n">layer</span><span class="p">,</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">use_raw</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="c1"># return subset</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">rank_genes_groups_df</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s1">&#39;grpA&#39;</span><span class="p">,</span> <span class="n">pval_cutoff</span><span class="o">=</span><span class="n">pval</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.utils.read_gmt" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">read_gmt</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">read_gmt</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Read a Gene Matrix Transposed (GMT) file and return a dictionary of gene sets.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>file_path</code></b>
              (<code>str</code>)
          –
          <div class="doc-md-description">
            <p>Path to the GMT file.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
<b><code>dict</code></b> (              <code>dict</code>
)          –
          <div class="doc-md-description">
            <p>A dictionary where keys are gene set names and values are lists of associated genes.</p>
          </div>
        </li>
    </ul>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/utils/annotation.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">read_gmt</span><span class="p">(</span><span class="n">file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read a Gene Matrix Transposed (GMT) file and return a dictionary of gene sets.</span>

<span class="sd">    Args:</span>
<span class="sd">        file_path (str): Path to the GMT file.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: A dictionary where keys are gene set names and values are lists of associated genes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gene_sets</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">gmt_file</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">gmt_file</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">gene_set_name</span> <span class="o">=</span> <span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">description</span> <span class="o">=</span> <span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># This can be ignored if not needed</span>
            <span class="n">genes</span> <span class="o">=</span> <span class="n">columns</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>

            <span class="n">gene_sets</span><span class="p">[</span><span class="n">gene_set_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">genes</span>

    <span class="k">return</span> <span class="n">gene_sets</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.utils.reassign_selected_clusters" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">reassign_selected_clusters</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">reassign_selected_clusters</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">dendro_key</span><span class="p">,</span> <span class="n">current_label</span><span class="p">,</span> <span class="n">new_label</span><span class="p">,</span> <span class="n">clusters_to_clean</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Reassign cells whose cluster is in <code>clusters_to_clean</code> by picking the 
highest-correlation cluster from the dendrogram correlation matrix.</p>
<p>We fix Scanpy's default behavior where:
  - 'categories_ordered' (leaf order) != the row order in 'correlation_matrix'.
  - Instead, 'categories_idx_ordered' is the permutation that maps leaf positions 
    to row indices in the original correlation matrix.</p>
<h5 id="pySingleCellNet.utils.reassign_selected_clusters--parameters">Parameters</h5>
<p>adata : anndata.AnnData
    Must contain:
      - adata.obs[current_label]: the current cluster assignments (strings).
      - adata.uns[dendro_key]: a dict with:
         * "categories_ordered": list of cluster labels in dendrogram (leaf) order
         * "categories_idx_ordered": list of row indices corresponding to the above
         * "correlation_matrix": the NxN matrix of correlations in the original order
dendro_key : str
    Key in adata.uns that has the dendrogram data.
current_label : str
    Column in adata.obs containing the current cluster assignments.
new_label : str
    Column name in adata.obs where we store the reassigned clusters.
clusters_to_clean : list or set of str, optional
    Labels that should be reassigned. If None, nothing will be cleaned.</p>
<h5 id="pySingleCellNet.utils.reassign_selected_clusters--returns">Returns</h5>
<p>None
    Adds a new column <code>adata.obs[new_label]</code> with updated assignments.</p>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/utils/cell.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">reassign_selected_clusters</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">,</span>
    <span class="n">dendro_key</span><span class="p">,</span>
    <span class="n">current_label</span><span class="p">,</span>
    <span class="n">new_label</span><span class="p">,</span>
    <span class="n">clusters_to_clean</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reassign cells whose cluster is in `clusters_to_clean` by picking the </span>
<span class="sd">    highest-correlation cluster from the dendrogram correlation matrix.</span>

<span class="sd">    We fix Scanpy&#39;s default behavior where:</span>
<span class="sd">      - &#39;categories_ordered&#39; (leaf order) != the row order in &#39;correlation_matrix&#39;.</span>
<span class="sd">      - Instead, &#39;categories_idx_ordered&#39; is the permutation that maps leaf positions </span>
<span class="sd">        to row indices in the original correlation matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adata : anndata.AnnData</span>
<span class="sd">        Must contain:</span>
<span class="sd">          - adata.obs[current_label]: the current cluster assignments (strings).</span>
<span class="sd">          - adata.uns[dendro_key]: a dict with:</span>
<span class="sd">             * &quot;categories_ordered&quot;: list of cluster labels in dendrogram (leaf) order</span>
<span class="sd">             * &quot;categories_idx_ordered&quot;: list of row indices corresponding to the above</span>
<span class="sd">             * &quot;correlation_matrix&quot;: the NxN matrix of correlations in the original order</span>
<span class="sd">    dendro_key : str</span>
<span class="sd">        Key in adata.uns that has the dendrogram data.</span>
<span class="sd">    current_label : str</span>
<span class="sd">        Column in adata.obs containing the current cluster assignments.</span>
<span class="sd">    new_label : str</span>
<span class="sd">        Column name in adata.obs where we store the reassigned clusters.</span>
<span class="sd">    clusters_to_clean : list or set of str, optional</span>
<span class="sd">        Labels that should be reassigned. If None, nothing will be cleaned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        Adds a new column `adata.obs[new_label]` with updated assignments.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">clusters_to_clean</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">clusters_to_clean</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">clusters_to_clean_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">clusters_to_clean</span><span class="p">)</span>

    <span class="c1"># Ensure the column is string (not categorical) to avoid assignment issues</span>
    <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_categorical_dtype</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">current_label</span><span class="p">]):</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">current_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">current_label</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>

    <span class="c1"># Pull out original assignments</span>
    <span class="n">original_assignments</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">current_label</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">new_assignments</span> <span class="o">=</span> <span class="n">original_assignments</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Retrieve dendrogram data</span>
    <span class="k">if</span> <span class="n">dendro_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">uns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dendro_key</span><span class="si">}</span><span class="s2"> not found in adata.uns.&quot;</span><span class="p">)</span>
    <span class="n">dendro_data</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="n">dendro_key</span><span class="p">]</span>

    <span class="n">categories_ordered</span> <span class="o">=</span> <span class="n">dendro_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;categories_ordered&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>      <span class="c1"># Leaf labels</span>
    <span class="n">leaves</span> <span class="o">=</span> <span class="n">dendro_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;categories_idx_ordered&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>             <span class="c1"># Leaf indices</span>
    <span class="n">corr_matrix</span> <span class="o">=</span> <span class="n">dendro_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;correlation_matrix&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">categories_ordered</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">leaves</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">corr_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;adata.uns[&#39;</span><span class="si">{</span><span class="n">dendro_key</span><span class="si">}</span><span class="s2">&#39;] must contain &quot;</span>
            <span class="s2">&quot;&#39;categories_ordered&#39;, &#39;categories_idx_ordered&#39;, and &#39;correlation_matrix&#39;.&quot;</span>
        <span class="p">)</span>

    <span class="n">n_cats</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">categories_ordered</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n_cats</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaves</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mismatch: categories_ordered and categories_idx_ordered differ in length.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">corr_matrix</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n_cats</span><span class="p">,</span> <span class="n">n_cats</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mismatch: correlation_matrix shape does not match number of categories.&quot;</span><span class="p">)</span>

    <span class="c1"># --------------------------------------------------------</span>
    <span class="c1"># 1) Reconstruct the &quot;original&quot; category order used in corr_matrix</span>
    <span class="c1">#    Because Scanpy does not reorder corr_matrix to the dendrogram&#39;s leaf order;</span>
    <span class="c1">#    instead it stores the &quot;dendrogram order&quot; in leaves + categories_ordered.</span>
    <span class="c1">#</span>
    <span class="c1">#    categories_ordered[i] = label at leaf i</span>
    <span class="c1">#    leaves[i] = index in the original order for that leaf</span>
    <span class="c1">#</span>
    <span class="c1">#    So if leaves = [2, 0, 1], it means:</span>
    <span class="c1">#      - leaf 0 is originally row 2,</span>
    <span class="c1">#      - leaf 1 is originally row 0,</span>
    <span class="c1">#      - leaf 2 is originally row 1.</span>
    <span class="c1">#</span>
    <span class="c1">#    We&#39;ll invert that so original_categories[row_idx] = label for that row.</span>
    <span class="c1"># --------------------------------------------------------</span>
    <span class="n">original_categories</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">n_cats</span>
    <span class="k">for</span> <span class="n">leaf_pos</span><span class="p">,</span> <span class="n">row_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">leaves</span><span class="p">):</span>
        <span class="c1"># categories_ordered[leaf_pos] is the label at leaf_pos</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">categories_ordered</span><span class="p">[</span><span class="n">leaf_pos</span><span class="p">]</span>
        <span class="n">original_categories</span><span class="p">[</span><span class="n">row_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>

    <span class="c1"># Build a lookup from label -&gt; row index in corr_matrix</span>
    <span class="n">label_to_idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">lbl</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">original_categories</span><span class="p">)}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">find_closest_cluster</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the label whose correlation is highest with `label`, </span>
<span class="sd">        skipping the label itself and any in clusters_to_clean_set.</span>

<span class="sd">        &#39;corr_matrix&#39; is in the &quot;original&quot; order, </span>
<span class="sd">        so we find its row via &#39;label_to_idx[label]&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">label_to_idx</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># no data for this label</span>
        <span class="n">row_idx</span> <span class="o">=</span> <span class="n">label_to_idx</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">corr_matrix</span><span class="p">[</span><span class="n">row_idx</span><span class="p">]</span>

        <span class="c1"># Sort indices by descending correlation</span>
        <span class="n">sorted_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">row</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># highest corr first</span>

        <span class="k">for</span> <span class="n">idx_</span> <span class="ow">in</span> <span class="n">sorted_idx</span><span class="p">:</span>
            <span class="c1"># skip itself</span>
            <span class="k">if</span> <span class="n">idx_</span> <span class="o">==</span> <span class="n">row_idx</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">candidate_label</span> <span class="o">=</span> <span class="n">original_categories</span><span class="p">[</span><span class="n">idx_</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">candidate_label</span> <span class="ow">in</span> <span class="n">clusters_to_clean_set</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># skip &quot;clean&quot; labels</span>
            <span class="k">return</span> <span class="n">candidate_label</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Reassign if needed</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_assignments</span><span class="p">)):</span>
        <span class="n">c_label</span> <span class="o">=</span> <span class="n">new_assignments</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">c_label</span> <span class="ow">in</span> <span class="n">clusters_to_clean_set</span><span class="p">:</span>
            <span class="n">fallback</span> <span class="o">=</span> <span class="n">find_closest_cluster</span><span class="p">(</span><span class="n">c_label</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fallback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_assignments</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fallback</span>
            <span class="c1"># else remain in the same cluster</span>

    <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">new_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_assignments</span>
    <span class="c1"># make sure type is category, seems to be needed for sc.tl.dendrogram</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">new_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">new_label</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.utils.rename_cluster_labels" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">rename_cluster_labels</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">rename_cluster_labels</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">old_col</span><span class="o">=</span><span class="s1">&#39;cluster&#39;</span><span class="p">,</span> <span class="n">new_col</span><span class="o">=</span><span class="s1">&#39;short_cluster&#39;</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Renames cluster labels in the specified .obs column with multi-letter codes.</p>
<ul>
<li>All unique labels (including NaN) are mapped in order of appearance to 
  a base-26 style ID: 'A', 'B', ..., 'Z', 'AA', 'AB', etc.</li>
<li>The new labels are stored as a categorical column in <code>adata.obs[new_col]</code>.</li>
</ul>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>adata</code></b>
              (<code>AnnData</code>)
          –
          <div class="doc-md-description">
            <p>The AnnData object containing the cluster labels.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>old_col</code></b>
              (<code>str</code>, default:
                  <code>&#39;cluster&#39;</code>
)
          –
          <div class="doc-md-description">
            <p>The name of the .obs column that has the original cluster labels.
Defaults to "cluster".</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>new_col</code></b>
              (<code>str</code>, default:
                  <code>&#39;short_cluster&#39;</code>
)
          –
          <div class="doc-md-description">
            <p>The name of the new .obs column that will store the shortened labels.
Defaults to "short_cluster".</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
<b><code>None</code></b> (              <code>None</code>
)          –
          <div class="doc-md-description">
            <p>The function adds a new column to <code>adata.obs</code> in place.</p>
          </div>
        </li>
    </ul>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/utils/cell.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">rename_cluster_labels</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span>
    <span class="n">old_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;cluster&quot;</span><span class="p">,</span>
    <span class="n">new_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;short_cluster&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Renames cluster labels in the specified .obs column with multi-letter codes.</span>

<span class="sd">    - All unique labels (including NaN) are mapped in order of appearance to </span>
<span class="sd">      a base-26 style ID: &#39;A&#39;, &#39;B&#39;, ..., &#39;Z&#39;, &#39;AA&#39;, &#39;AB&#39;, etc.</span>
<span class="sd">    - The new labels are stored as a categorical column in `adata.obs[new_col]`.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata (AnnData):</span>
<span class="sd">            The AnnData object containing the cluster labels.</span>
<span class="sd">        old_col (str, optional):</span>
<span class="sd">            The name of the .obs column that has the original cluster labels.</span>
<span class="sd">            Defaults to &quot;cluster&quot;.</span>
<span class="sd">        new_col (str, optional):</span>
<span class="sd">            The name of the new .obs column that will store the shortened labels.</span>
<span class="sd">            Defaults to &quot;short_cluster&quot;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: The function adds a new column to `adata.obs` in place.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># 1. Extract unique labels (including NaN), in the order they appear</span>
    <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">old_col</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

    <span class="c1"># 2. Helper function for base-26 labeling</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">index_to_label</span><span class="p">(</span><span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a zero-based index to a base-26 letter code:</span>
<span class="sd">        0 -&gt; A</span>
<span class="sd">        1 -&gt; B</span>
<span class="sd">        ...</span>
<span class="sd">        25 -&gt; Z</span>
<span class="sd">        26 -&gt; AA</span>
<span class="sd">        27 -&gt; AB</span>
<span class="sd">        ...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">letters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">remainder</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">%</span> <span class="mi">26</span>
            <span class="n">letter</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">remainder</span><span class="p">)</span>
            <span class="n">letters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">//</span> <span class="mi">26</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">letters</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># 3. Build the mapping (including NaN -&gt; next code)</span>
    <span class="n">label_map</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_labels</span><span class="p">):</span>
        <span class="n">label_map</span><span class="p">[</span><span class="n">lbl</span><span class="p">]</span> <span class="o">=</span> <span class="n">index_to_label</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="c1"># 4. Apply the mapping to create the new column</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">new_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">old_col</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">label_map</span><span class="p">)</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">new_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">new_col</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;category&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.utils.score_sex" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">score_sex</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">score_sex</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">y_genes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Eif2s3y&#39;</span><span class="p">,</span> <span class="s1">&#39;Ddx3y&#39;</span><span class="p">,</span> <span class="s1">&#39;Uty&#39;</span><span class="p">],</span> <span class="n">x_inactivation_genes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Xist&#39;</span><span class="p">,</span> <span class="s1">&#39;Tsix&#39;</span><span class="p">])</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Adds sex chromosome expression scores to an AnnData object.</p>


<details class="this-function-calculates-two-scores-for-each-cell-in-a-scrna-seq-anndata-object" open>
  <summary>This function calculates two scores for each cell in a scRNA-seq AnnData object</summary>
  <ul>
<li>Y_score: the sum of expression values for a set of Y-chromosome specific genes.</li>
<li>X_inact_score: the sum of expression values for genes involved in X-chromosome inactivation.</li>
</ul>
</details>        <p>The scores are added to the AnnData object's <code>.obs</code> DataFrame with the keys 'Y_score' and 'X_inact_score'.</p>
<h5 id="pySingleCellNet.utils.score_sex--parameters">Parameters</h5>
<p>adata : AnnData
    An AnnData object containing scRNA-seq data, with gene names in <code>adata.var_names</code>.
y_genes : list of str, optional
    List of Y-chromosome specific marker genes (default is ['Eif2s3y', 'Ddx3y', 'Uty']).
x_inactivation_genes : list of str, optional
    List of genes involved in X-chromosome inactivation (default is ['Xist', 'Tsix']).</p>
<h5 id="pySingleCellNet.utils.score_sex--raises">Raises</h5>
<p>ValueError
    If none of the Y-specific or X inactivation genes are found in <code>adata.var_names</code>.</p>
<h5 id="pySingleCellNet.utils.score_sex--returns">Returns</h5>
<p>None
    The function modifies the AnnData object in place by adding the score columns to <code>adata.obs</code>.</p>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/utils/gene.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">score_sex</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">,</span> 
    <span class="n">y_genes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Eif2s3y&#39;</span><span class="p">,</span> <span class="s1">&#39;Ddx3y&#39;</span><span class="p">,</span> <span class="s1">&#39;Uty&#39;</span><span class="p">],</span> 
    <span class="n">x_inactivation_genes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Xist&#39;</span><span class="p">,</span> <span class="s1">&#39;Tsix&#39;</span><span class="p">]</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds sex chromosome expression scores to an AnnData object.</span>

<span class="sd">    This function calculates two scores for each cell in a scRNA-seq AnnData object:</span>
<span class="sd">      - Y_score: the sum of expression values for a set of Y-chromosome specific genes.</span>
<span class="sd">      - X_inact_score: the sum of expression values for genes involved in X-chromosome inactivation.</span>

<span class="sd">    The scores are added to the AnnData object&#39;s `.obs` DataFrame with the keys &#39;Y_score&#39; and &#39;X_inact_score&#39;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    adata : AnnData</span>
<span class="sd">        An AnnData object containing scRNA-seq data, with gene names in `adata.var_names`.</span>
<span class="sd">    y_genes : list of str, optional</span>
<span class="sd">        List of Y-chromosome specific marker genes (default is [&#39;Eif2s3y&#39;, &#39;Ddx3y&#39;, &#39;Uty&#39;]).</span>
<span class="sd">    x_inactivation_genes : list of str, optional</span>
<span class="sd">        List of genes involved in X-chromosome inactivation (default is [&#39;Xist&#39;, &#39;Tsix&#39;]).</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If none of the Y-specific or X inactivation genes are found in `adata.var_names`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        The function modifies the AnnData object in place by adding the score columns to `adata.obs`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Filter for genes that are available in the dataset.</span>
    <span class="n">available_y_genes</span> <span class="o">=</span> <span class="p">[</span><span class="n">gene</span> <span class="k">for</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">y_genes</span> <span class="k">if</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="p">]</span>
    <span class="n">available_x_genes</span> <span class="o">=</span> <span class="p">[</span><span class="n">gene</span> <span class="k">for</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">x_inactivation_genes</span> <span class="k">if</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">available_y_genes</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;None of the Y-specific genes were found in the dataset.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">available_x_genes</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;None of the X inactivation genes were found in the dataset.&quot;</span><span class="p">)</span>

    <span class="c1"># Compute the sum of expression for the Y-specific genes.</span>
    <span class="n">y_expression</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[:,</span> <span class="n">available_y_genes</span><span class="p">]</span><span class="o">.</span><span class="n">X</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">y_expression</span><span class="p">,</span> <span class="s2">&quot;toarray&quot;</span><span class="p">):</span>
        <span class="n">y_expression</span> <span class="o">=</span> <span class="n">y_expression</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;Y_score&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y_expression</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Compute the sum of expression for the X inactivation genes.</span>
    <span class="n">x_expression</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[:,</span> <span class="n">available_x_genes</span><span class="p">]</span><span class="o">.</span><span class="n">X</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x_expression</span><span class="p">,</span> <span class="s2">&quot;toarray&quot;</span><span class="p">):</span>
        <span class="n">x_expression</span> <span class="o">=</span> <span class="n">x_expression</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;X_inact_score&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x_expression</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Optionally, you could log some output:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Added &#39;Y_score&#39; and &#39;X_inact_score&#39; to adata.obs for </span><span class="si">{}</span><span class="s2"> cells.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">n_obs</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.utils.sort_obs_table" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">sort_obs_table</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">sort_obs_table</span><span class="p">(</span><span class="n">adata</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Sorts the observation table of an AnnData object by 'celltype' and the numeric part of 'stage'.</p>
<p>This function takes an AnnData object as input, extracts the 'celltype' and 'stage' columns 
from its observation (obs) DataFrame, counts the occurrences of each unique pair, and sorts 
these counts first by 'celltype' and then by the numeric value extracted from 'stage'.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>adata</code></b>
              (<code>AnnData</code>)
          –
          <div class="doc-md-description">
            <p>An AnnData object containing the single-cell dataset.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
          –
          <div class="doc-md-description">
            <p>pandas.DataFrame: A DataFrame with sorted counts of cell types and stages.</p>
          </div>
        </li>
    </ul>


<details class="notes" open>
  <summary>Notes</summary>
  <p>The 'stage' column is expected to contain string values with a numeric part that can be 
extracted and sorted numerically. The function does not modify the original AnnData object.</p>
</details>
            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/utils/cell.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">sort_obs_table</span><span class="p">(</span><span class="n">adata</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sorts the observation table of an AnnData object by &#39;celltype&#39; and the numeric part of &#39;stage&#39;.</span>

<span class="sd">    This function takes an AnnData object as input, extracts the &#39;celltype&#39; and &#39;stage&#39; columns </span>
<span class="sd">    from its observation (obs) DataFrame, counts the occurrences of each unique pair, and sorts </span>
<span class="sd">    these counts first by &#39;celltype&#39; and then by the numeric value extracted from &#39;stage&#39;.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata (AnnData): An AnnData object containing the single-cell dataset.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame: A DataFrame with sorted counts of cell types and stages.</span>

<span class="sd">    Notes:</span>
<span class="sd">        The &#39;stage&#39; column is expected to contain string values with a numeric part that can be </span>
<span class="sd">        extracted and sorted numerically. The function does not modify the original AnnData object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Count occurrences of each unique &#39;celltype&#39; and &#39;stage&#39; pair</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[[</span><span class="s1">&#39;celltype&#39;</span><span class="p">,</span> <span class="s1">&#39;stage&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
    <span class="n">counts_df</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="n">counts_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;celltype&#39;</span><span class="p">,</span> <span class="s1">&#39;stage&#39;</span><span class="p">,</span> <span class="s1">&#39;count&#39;</span><span class="p">]</span>

    <span class="c1"># Add a temporary column &#39;stage_num&#39; for numeric sorting of &#39;stage&#39;</span>
    <span class="c1"># Then sort by &#39;celltype&#39; and the numeric part of &#39;stage&#39;</span>
    <span class="c1"># Finally, drop the temporary &#39;stage_num&#39; column</span>
    <span class="n">counts_df</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">counts_df</span>
        <span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">stage_num</span><span class="o">=</span><span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;stage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\d+\.\d+|\d+)&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">))</span>
        <span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;celltype&#39;</span><span class="p">,</span> <span class="s1">&#39;stage_num&#39;</span><span class="p">])</span>
        <span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s1">&#39;stage_num&#39;</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">counts_df</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.utils.split_adata_indices" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">split_adata_indices</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">split_adata_indices</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">n_cells</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">groupby</span><span class="o">=</span><span class="s1">&#39;cell_ontology_class&#39;</span><span class="p">,</span> <span class="n">cellid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strata_col</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Splits an AnnData object into training and validation indices based on stratification by cell type
and optionally by another categorical variable.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>adata</code></b>
              (<code>AnnData</code>)
          –
          <div class="doc-md-description">
            <p>The annotated data matrix to split.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>n_cells</code></b>
              (<code>int</code>, default:
                  <code>100</code>
)
          –
          <div class="doc-md-description">
            <p>The number of cells to sample per cell type.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>groupby</code></b>
              (<code>str</code>, default:
                  <code>&#39;cell_ontology_class&#39;</code>
)
          –
          <div class="doc-md-description">
            <p>The column name in adata.obs that specifies the cell type.
                     Defaults to "cell_ontology_class".</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>cellid</code></b>
              (<code>str</code>, default:
                  <code>None</code>
)
          –
          <div class="doc-md-description">
            <p>The column in adata.obs to use as a unique identifier for cells.
                    If None, it defaults to using the index.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>strata_col</code></b>
              (<code>str</code>, default:
                  <code>None</code>
)
          –
          <div class="doc-md-description">
            <p>The column name in adata.obs used for secondary stratification,
                        such as developmental stage, gender, or disease status.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
<b><code>tuple</code></b> (              <code>tuple</code>
)          –
          <div class="doc-md-description">
            <p>A tuple containing two lists:
- training_indices (list): List of indices for the training set.
- validation_indices (list): List of indices for the validation set.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>ValueError</code>
            –
          <div class="doc-md-description">
            <p>If any specified column names do not exist in the DataFrame.</p>
          </div>
        </li>
    </ul>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/utils/cell.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">split_adata_indices</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">,</span>
    <span class="n">n_cells</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="n">groupby</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;cell_ontology_class&quot;</span><span class="p">,</span>
    <span class="n">cellid</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">strata_col</span><span class="p">:</span> <span class="nb">str</span>  <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits an AnnData object into training and validation indices based on stratification by cell type</span>
<span class="sd">    and optionally by another categorical variable.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata (AnnData): The annotated data matrix to split.</span>
<span class="sd">        n_cells (int): The number of cells to sample per cell type.</span>
<span class="sd">        groupby (str, optional): The column name in adata.obs that specifies the cell type.</span>
<span class="sd">                                 Defaults to &quot;cell_ontology_class&quot;.</span>
<span class="sd">        cellid (str, optional): The column in adata.obs to use as a unique identifier for cells.</span>
<span class="sd">                                If None, it defaults to using the index.</span>
<span class="sd">        strata_col (str, optional): The column name in adata.obs used for secondary stratification,</span>
<span class="sd">                                    such as developmental stage, gender, or disease status.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing two lists:</span>
<span class="sd">            - training_indices (list): List of indices for the training set.</span>
<span class="sd">            - validation_indices (list): List of indices for the validation set.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If any specified column names do not exist in the DataFrame.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cellid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s2">&quot;cellid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">index</span>
        <span class="n">cellid</span> <span class="o">=</span> <span class="s2">&quot;cellid&quot;</span>
    <span class="k">if</span> <span class="n">groupby</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="p">(</span><span class="n">strata_col</span> <span class="ow">and</span> <span class="n">strata_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Specified column names do not exist in the DataFrame.&quot;</span><span class="p">)</span>

    <span class="n">cts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">groupby</span><span class="p">])</span>
    <span class="n">trainingids</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">ct</span> <span class="ow">in</span> <span class="n">cts</span><span class="p">:</span>
        <span class="n">subset</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">groupby</span><span class="p">]</span> <span class="o">==</span> <span class="n">ct</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">strata_col</span><span class="p">:</span>
            <span class="n">stratified_ids</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">strata_groups</span> <span class="o">=</span> <span class="n">subset</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">strata_col</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            <span class="n">n_strata</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">strata_groups</span><span class="p">)</span>

            <span class="c1"># Initialize desired count and structure to store samples per strata</span>
            <span class="n">desired_per_group</span> <span class="o">=</span> <span class="n">n_cells</span> <span class="o">//</span> <span class="n">n_strata</span>
            <span class="n">samples_per_group</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">remaining</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># First pass: allocate base quota or maximum available if less than base</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">strata_groups</span><span class="p">:</span>
                <span class="n">group_subset</span> <span class="o">=</span> <span class="n">subset</span><span class="p">[</span><span class="n">subset</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">strata_col</span><span class="p">]</span> <span class="o">==</span> <span class="n">group</span><span class="p">]</span>
                <span class="n">available</span> <span class="o">=</span> <span class="n">group_subset</span><span class="o">.</span><span class="n">n_obs</span>
                <span class="k">if</span> <span class="n">available</span> <span class="o">&lt;</span> <span class="n">desired_per_group</span><span class="p">:</span>
                    <span class="n">samples_per_group</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">available</span>
                    <span class="n">remaining</span> <span class="o">+=</span> <span class="n">desired_per_group</span> <span class="o">-</span> <span class="n">available</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">samples_per_group</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">desired_per_group</span>

            <span class="c1"># Second pass: redistribute remaining quota among groups that can supply more</span>
            <span class="c1"># Continue redistributing until either there&#39;s no remaining quota or no group can supply more.</span>
            <span class="n">groups_can_supply</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">while</span> <span class="n">remaining</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">groups_can_supply</span><span class="p">:</span>
                <span class="n">groups_can_supply</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">strata_groups</span><span class="p">:</span>
                    <span class="n">group_subset</span> <span class="o">=</span> <span class="n">subset</span><span class="p">[</span><span class="n">subset</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">strata_col</span><span class="p">]</span> <span class="o">==</span> <span class="n">group</span><span class="p">]</span>
                    <span class="n">available</span> <span class="o">=</span> <span class="n">group_subset</span><span class="o">.</span><span class="n">n_obs</span>
                    <span class="c1"># Check if this group can supply an extra cell beyond what we&#39;ve allocated so far</span>
                    <span class="k">if</span> <span class="n">samples_per_group</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">available</span><span class="p">:</span>
                        <span class="n">samples_per_group</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">remaining</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">groups_can_supply</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">if</span> <span class="n">remaining</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">break</span>

            <span class="c1"># Sample cells for each strata group based on the determined counts</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">strata_groups</span><span class="p">:</span>
                <span class="n">group_subset</span> <span class="o">=</span> <span class="n">subset</span><span class="p">[</span><span class="n">subset</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">strata_col</span><span class="p">]</span> <span class="o">==</span> <span class="n">group</span><span class="p">]</span>
                <span class="n">count_to_sample</span> <span class="o">=</span> <span class="n">samples_per_group</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">count_to_sample</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">sampled_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span>
                        <span class="n">group_subset</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cellid</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> 
                        <span class="n">count_to_sample</span><span class="p">,</span> 
                        <span class="n">replace</span><span class="o">=</span><span class="kc">False</span>
                    <span class="p">)</span>
                    <span class="n">stratified_ids</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sampled_ids</span><span class="p">)</span>

            <span class="n">trainingids</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">stratified_ids</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ccount</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">subset</span><span class="o">.</span><span class="n">n_obs</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">)</span>
            <span class="n">sampled_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">subset</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cellid</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">ccount</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">trainingids</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sampled_ids</span><span class="p">)</span>

    <span class="c1"># Get all unique IDs</span>
    <span class="n">all_ids</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cellid</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="c1"># Determine validation IDs</span>
    <span class="n">assume_unique</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs_names</span><span class="o">.</span><span class="n">is_unique</span>
    <span class="n">val_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">all_ids</span><span class="p">,</span> <span class="n">trainingids</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="n">assume_unique</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">trainingids</span><span class="p">,</span> <span class="n">val_ids</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.utils.write_gmt" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">write_gmt</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">write_gmt</span><span class="p">(</span><span class="n">gene_list</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">collection_name</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Write a .gmt file from a gene list.</p>
        <p>gene_list: dict
    Dictionary of gene sets (keys are gene set names, values are lists of genes).
filename: str
    The name of the file to write to.
collection_name: str
    The name of the gene set collection.
prefix: str, optional
    A prefix to add to each gene set name.</p>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/utils/annotation.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">write_gmt</span><span class="p">(</span><span class="n">gene_list</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">collection_name</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Write a .gmt file from a gene list.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    gene_list: dict</span>
<span class="sd">        Dictionary of gene sets (keys are gene set names, values are lists of genes).</span>
<span class="sd">    filename: str</span>
<span class="sd">        The name of the file to write to.</span>
<span class="sd">    collection_name: str</span>
<span class="sd">        The name of the gene set collection.</span>
<span class="sd">    prefix: str, optional</span>
<span class="sd">        A prefix to add to each gene set name.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fo</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">akey</span> <span class="ow">in</span> <span class="n">gene_list</span><span class="p">:</span>
            <span class="c1"># replace whitespace with a &quot;_&quot;</span>
            <span class="n">gl_name</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s+&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">akey</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">prefix</span><span class="p">:</span>
                <span class="n">pfix</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">gl_name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pfix</span> <span class="o">=</span> <span class="n">gl_name</span>
            <span class="n">preface</span> <span class="o">=</span> <span class="n">pfix</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">collection_name</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">preface</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">gene_list</span><span class="p">[</span><span class="n">akey</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">fo</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2024 Cahan Lab
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": ".", "features": ["content.footnote.tooltips", "navigation.expand", "toc.integrate"], "search": "assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="assets/javascripts/bundle.88dd0f4e.min.js"></script>
      
        <script src="javascripts/extra.js"></script>
      
    
  </body>
</html>