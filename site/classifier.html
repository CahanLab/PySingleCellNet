
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
        <meta name="author" content="Patrick Cahan">
      
      
      
        <link rel="prev" href="utils.html">
      
      
        <link rel="next" href="plotting.html">
      
      
      <link rel="icon" href="img/logo.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.49">
    
    
      
        <title>Classifier functions - pySingleCellNet</title>
      
    
    
      <link rel="stylesheet" href="assets/stylesheets/main.6f8fc17f.min.css">
      
        
        <link rel="stylesheet" href="assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Noto Sans";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="assets/_mkdocstrings.css">
    
      <link rel="stylesheet" href="stylesheets/extra.css">
    
    <script>__md_scope=new URL(".",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="light-blue" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#classifier-functions" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="." title="pySingleCellNet" class="md-header__button md-logo" aria-label="pySingleCellNet" data-md-component="logo">
      
  <img src="img/logoGlow.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            pySingleCellNet
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Classifier functions
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/CahanLab/PySingleCellNet" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



  

<nav class="md-nav md-nav--primary md-nav--integrated" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="." title="pySingleCellNet" class="md-nav__button md-logo" aria-label="pySingleCellNet" data-md-component="logo">
      
  <img src="img/logoGlow.png" alt="logo">

    </a>
    pySingleCellNet
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/CahanLab/PySingleCellNet" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.7.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="install.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Installation
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
          
        
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Tutorials
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Tutorials
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="notebooks/quickstart.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Quickstart
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="notebooks/categorize.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Explore
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="training_data.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Training data
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="refs.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    References
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" checked>
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    API
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            API
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="utils.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Utility functions
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Classifier functions
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="classifier.html" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Classifier functions
  </span>
  

      </a>
      
        

  

<nav class="md-nav md-nav--secondary" aria-label="On this page">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      On this page
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.classify" class="md-nav__link">
    <span class="md-ellipsis">
      classify
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.classify.categorize_classification" class="md-nav__link">
    <span class="md-ellipsis">
      categorize_classification
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.classify.classify_anndata" class="md-nav__link">
    <span class="md-ellipsis">
      classify_anndata
    </span>
  </a>
  
    <nav class="md-nav" aria-label="classify_anndata">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pySingleCellNet.classify.classify_anndata--parameters" class="md-nav__link">
    <span class="md-ellipsis">
      Parameters:
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pySingleCellNet.classify.classify_anndata--returns" class="md-nav__link">
    <span class="md-ellipsis">
      Returns:
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.classify.collect_gsea_results_from_dict" class="md-nav__link">
    <span class="md-ellipsis">
      collect_gsea_results_from_dict
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.classify.comp_ct_thresh" class="md-nav__link">
    <span class="md-ellipsis">
      comp_ct_thresh
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.classify.convert_diffExp_to_dict" class="md-nav__link">
    <span class="md-ellipsis">
      convert_diffExp_to_dict
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.classify.create_classifier_report" class="md-nav__link">
    <span class="md-ellipsis">
      create_classifier_report
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.classify.deg" class="md-nav__link">
    <span class="md-ellipsis">
      deg
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.classify.graph_from_nodes_and_edges" class="md-nav__link">
    <span class="md-ellipsis">
      graph_from_nodes_and_edges
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.classify.gsea_on_deg" class="md-nav__link">
    <span class="md-ellipsis">
      gsea_on_deg
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pySingleCellNet.classify.paga_connectivities_to_igraph" class="md-nav__link">
    <span class="md-ellipsis">
      paga_connectivities_to_igraph
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="plotting.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Plotting functions
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="classifier-functions">classifier functions</h1>
<p>Functions that create or require the classifier <code>clf</code> object.</p>


<div class="doc doc-object doc-module">



<a id="pySingleCellNet.classify"></a>
    <div class="doc doc-contents first">








  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.classify.categorize_classification" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">categorize_classification</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">categorize_classification</span><span class="p">(</span><span class="n">adata_c</span><span class="p">,</span> <span class="n">thresholds</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">columns_to_ignore</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;rand&#39;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">class_obs_name</span><span class="o">=</span><span class="s1">&#39;SCN_class_argmax&#39;</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Classify cells based on SCN scores and thresholds, then categorize 
multi-class cells as either 'Intermediate' or 'Hybrid'.</p>


<details class="classification-rules" open>
  <summary>Classification rules</summary>
  <ul>
<li>If exactly one cell type exceeds threshold: "Singular"</li>
<li>If zero cell types exceed threshold: "None"</li>
<li>If more than one cell type exceeds threshold:<ul>
<li>If all pairs of high-scoring cell types are within <code>k</code> edges 
  in the provided graph: "Intermediate"</li>
<li>Otherwise: "Hybrid"</li>
</ul>
</li>
<li>If predicted cell type is 'rand': Set classification to "Rand"</li>
</ul>
</details>

<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>adata_c</code></b>
              (<code><span title="anndata.AnnData">AnnData</span></code>)
          –
          <div class="doc-md-description">
            <p>Annotated data matrix containing:
- <code>.obsm["SCN_score"]</code>: DataFrame of SCN scores for each cell type.
- <code>.obs[class_obs_name]</code>: Predicted cell type (argmax classification).</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>thresholds</code></b>
              (<code><span title="pandas.DataFrame">DataFrame</span></code>)
          –
          <div class="doc-md-description">
            <p>Thresholds for each cell type. Expected to 
match the columns in <code>SCN_score</code>.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>graph</code></b>
              (<code><span title="igraph.Graph">Graph</span></code>, default:
                  <code>None</code>
)
          –
          <div class="doc-md-description">
            <p>An iGraph describing relationships between cell types. 
Must have vertex names matching the cell-type columns in SCN_score.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>k</code></b>
              (<code>int</code>, default:
                  <code>3</code>
)
          –
          <div class="doc-md-description">
            <p>Maximum graph distance to consider cell types "Intermediate". Defaults to 3.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>columns_to_ignore</code></b>
              (<code>list</code>, default:
                  <code>[&#39;rand&#39;]</code>
)
          –
          <div class="doc-md-description">
            <p>List of SCN score columns to ignore. Defaults to ["rand"].</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>inplace</code></b>
              (<code>bool</code>, default:
                  <code>True</code>
)
          –
          <div class="doc-md-description">
            <p>If True, modify <code>adata_c</code> in place. Otherwise, return a new AnnData object. Defaults to True.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>class_obs_name</code></b>
              (<code>str</code>, default:
                  <code>&#39;SCN_class_argmax&#39;</code>
)
          –
          <div class="doc-md-description">
            <p>The name of the <code>.obs</code> column with argmax classification. Defaults to 'SCN_class_argmax'.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>ValueError</code>
            –
          <div class="doc-md-description">
            <p>If <code>graph</code> is None.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code>ValueError</code>
            –
          <div class="doc-md-description">
            <p>If "SCN_score" is missing in <code>adata_c.obsm</code>.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code>ValueError</code>
            –
          <div class="doc-md-description">
            <p>If <code>class_obs_name</code> is not found in <code>adata_c.obs</code>.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code>ValueError</code>
            –
          <div class="doc-md-description">
            <p>If the provided graph does not have vertex "name" attributes.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
          –
          <div class="doc-md-description">
            <p>AnnData or None: Returns modified AnnData if <code>inplace</code> is False, otherwise None.</p>
          </div>
        </li>
    </ul>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/classify/categorize.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">categorize_classification</span><span class="p">(</span>
    <span class="n">adata_c</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">thresholds</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">graph</span><span class="p">:</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">columns_to_ignore</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;rand&quot;</span><span class="p">],</span>
    <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">class_obs_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;SCN_class_argmax&#39;</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Classify cells based on SCN scores and thresholds, then categorize </span>
<span class="sd">    multi-class cells as either &#39;Intermediate&#39; or &#39;Hybrid&#39;.</span>

<span class="sd">    Classification rules:</span>
<span class="sd">      - If exactly one cell type exceeds threshold: &quot;Singular&quot;</span>
<span class="sd">      - If zero cell types exceed threshold: &quot;None&quot;</span>
<span class="sd">      - If more than one cell type exceeds threshold:</span>
<span class="sd">          * If all pairs of high-scoring cell types are within `k` edges </span>
<span class="sd">            in the provided graph: &quot;Intermediate&quot;</span>
<span class="sd">          * Otherwise: &quot;Hybrid&quot;</span>
<span class="sd">      - If predicted cell type is &#39;rand&#39;: Set classification to &quot;Rand&quot;</span>

<span class="sd">    Args:</span>
<span class="sd">        adata_c (AnnData): Annotated data matrix containing:</span>
<span class="sd">            - `.obsm[&quot;SCN_score&quot;]`: DataFrame of SCN scores for each cell type.</span>
<span class="sd">            - `.obs[class_obs_name]`: Predicted cell type (argmax classification).</span>
<span class="sd">        thresholds (pd.DataFrame): Thresholds for each cell type. Expected to </span>
<span class="sd">            match the columns in `SCN_score`.</span>
<span class="sd">        graph (ig.Graph): An iGraph describing relationships between cell types. </span>
<span class="sd">            Must have vertex names matching the cell-type columns in SCN_score.</span>
<span class="sd">        k (int, optional): Maximum graph distance to consider cell types &quot;Intermediate&quot;. Defaults to 3.</span>
<span class="sd">        columns_to_ignore (list, optional): List of SCN score columns to ignore. Defaults to [&quot;rand&quot;].</span>
<span class="sd">        inplace (bool, optional): If True, modify `adata_c` in place. Otherwise, return a new AnnData object. Defaults to True.</span>
<span class="sd">        class_obs_name (str, optional): The name of the `.obs` column with argmax classification. Defaults to &#39;SCN_class_argmax&#39;.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If `graph` is None.</span>
<span class="sd">        ValueError: If &quot;SCN_score&quot; is missing in `adata_c.obsm`.</span>
<span class="sd">        ValueError: If `class_obs_name` is not found in `adata_c.obs`.</span>
<span class="sd">        ValueError: If the provided graph does not have vertex &quot;name&quot; attributes.</span>

<span class="sd">    Returns:</span>
<span class="sd">        AnnData or None: Returns modified AnnData if `inplace` is False, otherwise None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A valid iGraph &#39;graph&#39; must be provided. None was given.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="s2">&quot;SCN_score&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata_c</span><span class="o">.</span><span class="n">obsm</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No &#39;SCN_score&#39; in adata_c.obsm. Please provide SCN scores.&quot;</span><span class="p">)</span>

    <span class="n">SCN_scores</span> <span class="o">=</span> <span class="n">adata_c</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s2">&quot;SCN_score&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">SCN_scores</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns_to_ignore</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>

    <span class="n">exceeded</span> <span class="o">=</span> <span class="n">SCN_scores</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">thresholds</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">true_counts</span> <span class="o">=</span> <span class="n">exceeded</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">result_list</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">exceeded</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">exceeded</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">exceeded</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="p">]</span>

    <span class="n">class_type</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">&quot;None&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_counts</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">true_counts</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;SCN_class_type&quot;</span><span class="p">)</span>

    <span class="n">singular_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">true_counts</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">class_type</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">singular_mask</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Singular&quot;</span>

    <span class="k">if</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">vs</span><span class="o">.</span><span class="n">attributes</span><span class="p">():</span>
        <span class="n">type2index</span> <span class="o">=</span> <span class="p">{</span><span class="n">graph</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">vcount</span><span class="p">())}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;graph does not have a &#39;name&#39; attribute for vertices.&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">is_all_within_k_edges</span><span class="p">(</span><span class="n">cell_types</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if all pairs of cell types are within k edges in the graph.</span>

<span class="sd">        Args:</span>
<span class="sd">            cell_types (list): List of cell type names.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if all pairs are within k edges, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_types</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cell_types</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_types</span><span class="p">)):</span>
                <span class="n">ct1</span><span class="p">,</span> <span class="n">ct2</span> <span class="o">=</span> <span class="n">cell_types</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cell_types</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ct1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">type2index</span> <span class="ow">or</span> <span class="n">ct2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">type2index</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="n">idx1</span> <span class="o">=</span> <span class="n">type2index</span><span class="p">[</span><span class="n">ct1</span><span class="p">]</span>
                <span class="n">idx2</span> <span class="o">=</span> <span class="n">type2index</span><span class="p">[</span><span class="n">ct2</span><span class="p">]</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">shortest_paths</span><span class="p">(</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="n">multi_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">true_counts</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">multi_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">multi_mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">multi_indices</span><span class="p">:</span>
        <span class="n">c_types</span> <span class="o">=</span> <span class="n">result_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">is_all_within_k_edges</span><span class="p">(</span><span class="n">c_types</span><span class="p">):</span>
            <span class="n">class_type</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Intermediate&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">class_type</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Hybrid&quot;</span>

    <span class="n">ans</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="k">if</span> <span class="n">lst</span> <span class="k">else</span> <span class="s1">&#39;None&#39;</span> <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="n">result_list</span><span class="p">]</span>

    <span class="n">adata_c</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;SCN_class_emp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ans</span>
    <span class="n">adata_c</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;SCN_class_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">class_type</span>

    <span class="k">if</span> <span class="n">class_obs_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata_c</span><span class="o">.</span><span class="n">obs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">class_obs_name</span><span class="si">}</span><span class="s2"> not found in adata_c.obs.&quot;</span><span class="p">)</span>

    <span class="n">adata_c</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;SCN_class_emp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata_c</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="s1">&#39;Rand&#39;</span> <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">class_obs_name</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;rand&#39;</span> <span class="k">else</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;SCN_class_emp&#39;</span><span class="p">],</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>
    <span class="n">adata_c</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;SCN_class_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata_c</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="s1">&#39;Rand&#39;</span> <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">class_obs_name</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;rand&#39;</span> <span class="k">else</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;SCN_class_type&#39;</span><span class="p">],</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>

    <span class="n">_add_scn_class_cat</span><span class="p">(</span><span class="n">adata_c</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">adata_c</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.classify.classify_anndata" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">classify_anndata</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">classify_anndata</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">rf_tsp</span><span class="p">,</span> <span class="n">nrand</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Classifies cells in the <code>adata</code> object based on the given gene expression and cross-pair information using a
random forest classifier in rf_tsp trained with the provided xpairs genes.</p>
<h5 id="pySingleCellNet.classify.classify_anndata--parameters">Parameters:</h5>
<p>adata: <code>AnnData</code>
    An annotated data matrix containing the gene expression information for cells.
rf_tsp: List[float]
    A list of random forest classifier parameters used for classification.
nrand: int
    Number of random permutations for the null distribution. Default is 0.</p>
<h5 id="pySingleCellNet.classify.classify_anndata--returns">Returns:</h5>
<p>Updates adata with classification results</p>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/classify/classifier.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">classify_anndata</span><span class="p">(</span><span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span> <span class="n">rf_tsp</span><span class="p">,</span> <span class="n">nrand</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Classifies cells in the `adata` object based on the given gene expression and cross-pair information using a</span>
<span class="sd">    random forest classifier in rf_tsp trained with the provided xpairs genes.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    -----------</span>
<span class="sd">    adata: `AnnData`</span>
<span class="sd">        An annotated data matrix containing the gene expression information for cells.</span>
<span class="sd">    rf_tsp: List[float]</span>
<span class="sd">        A list of random forest classifier parameters used for classification.</span>
<span class="sd">    nrand: int</span>
<span class="sd">        Number of random permutations for the null distribution. Default is 0.</span>

<span class="sd">    Returns:</span>
<span class="sd">    --------</span>
<span class="sd">    Updates adata with classification results </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Classify cells using the `_scn_predict` function</span>
    <span class="n">classRes</span> <span class="o">=</span> <span class="n">_scn_predict</span><span class="p">(</span><span class="n">rf_tsp</span><span class="p">,</span> <span class="n">adata</span><span class="p">,</span> <span class="n">nrand</span><span class="o">=</span><span class="n">nrand</span><span class="p">)</span>

    <span class="c1"># add the classification result as to `obsm`</span>
    <span class="c1"># adNew = AnnData(classRes, obs=adata.obs, var=pd.DataFrame(index=categories))</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s1">&#39;SCN_score&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">classRes</span>

    <span class="c1"># Get the categories (i.e., predicted cell types) from the classification result</span>
    <span class="c1"># categories = classRes.columns.values</span>
    <span class="c1"># possible_classes = rf_tsp[&#39;classifier&#39;].classes_</span>
    <span class="n">possible_classes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">classRes</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
    <span class="c1"># Add a new column to `obs` for the predicted cell types</span>
    <span class="n">predicted_classes</span> <span class="o">=</span> <span class="n">classRes</span><span class="o">.</span><span class="n">idxmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;SCN_class_argmax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">predicted_classes</span><span class="p">,</span> <span class="n">categories</span><span class="o">=</span><span class="n">possible_classes</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># store this for consistent coloring</span>
    <span class="c1"># adata.uns[&#39;SCN_class_colors&#39;] = rf_tsp[&#39;ctColors&#39;]        </span>

    <span class="c1"># import matplotlib.colors as mcolors</span>
    <span class="c1"># celltype_colors = rf_tsp[&#39;ctColors&#39;]</span>
    <span class="c1"># mycolors = [celltype_colors[ct] for ct in adata.obs[&#39;SCN_class_argmax&#39;].cat.categories]</span>
    <span class="c1"># cmap = mcolors.ListedColormap(mycolors)</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s1">&#39;SCN_class_argmax_colors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rf_tsp</span><span class="p">[</span><span class="s1">&#39;ctColors&#39;</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.classify.collect_gsea_results_from_dict" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">collect_gsea_results_from_dict</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">collect_gsea_results_from_dict</span><span class="p">(</span><span class="n">gsea_dict2</span><span class="p">,</span> <span class="n">fdr_thr</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">top_n</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Collect and filter GSEA results from a dictionary of GSEA objects.</p>


<details class="for-each-cell-type" open>
  <summary>For each cell type</summary>
  <ol>
<li>Sets NES=0 for any gene set with FDR &gt; fdr_thr.</li>
<li>Selects up to top_n sets with the largest positive NES and 
   top_n with the most negative NES.</li>
</ol>
</details>        <p>The final output is limited to the union of all such selected sets
across all cell types, with zeroes preserved for cell types in which
the pathway is not among the top_n or fails the FDR threshold.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>gsea_dict2</code></b>
              (<code>dict</code>)
          –
          <div class="doc-md-description">
            <p>Dictionary mapping cell types to GSEA result objects.
Each object has a .res2d DataFrame with columns ["Term", "NES", "FDR q-val"].</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>fdr_thr</code></b>
              (<code>float</code>, default:
                  <code>0.25</code>
)
          –
          <div class="doc-md-description">
            <p>FDR threshold above which NES values are set to 0. 
Defaults to 0.25.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>top_n</code></b>
              (<code>int</code>, default:
                  <code>3</code>
)
          –
          <div class="doc-md-description">
            <p>Maximum number of positive and negative results 
(by NES) to keep per cell type. Defaults to 10.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
          –
          <div class="doc-md-description">
            <p>pd.DataFrame: A DataFrame whose rows are the union of selected gene sets 
across all cell types, and whose columns are cell types. Entries 
are filtered NES values (0 where FDR fails, or if not in the top_n).</p>
          </div>
        </li>
    </ul>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/classify/comparison.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">collect_gsea_results_from_dict</span><span class="p">(</span>
    <span class="n">gsea_dict2</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="n">fdr_thr</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.25</span><span class="p">,</span>
    <span class="n">top_n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Collect and filter GSEA results from a dictionary of GSEA objects.</span>

<span class="sd">    For each cell type:</span>
<span class="sd">      1. Sets NES=0 for any gene set with FDR &gt; fdr_thr.</span>
<span class="sd">      2. Selects up to top_n sets with the largest positive NES and </span>
<span class="sd">         top_n with the most negative NES.</span>

<span class="sd">    The final output is limited to the union of all such selected sets</span>
<span class="sd">    across all cell types, with zeroes preserved for cell types in which</span>
<span class="sd">    the pathway is not among the top_n or fails the FDR threshold.</span>

<span class="sd">    Args:</span>
<span class="sd">        gsea_dict2 (dict): Dictionary mapping cell types to GSEA result objects.</span>
<span class="sd">            Each object has a .res2d DataFrame with columns [&quot;Term&quot;, &quot;NES&quot;, &quot;FDR q-val&quot;].</span>
<span class="sd">        fdr_thr (float, optional): FDR threshold above which NES values are set to 0. </span>
<span class="sd">            Defaults to 0.25.</span>
<span class="sd">        top_n (int, optional): Maximum number of positive and negative results </span>
<span class="sd">            (by NES) to keep per cell type. Defaults to 10.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: A DataFrame whose rows are the union of selected gene sets </span>
<span class="sd">            across all cell types, and whose columns are cell types. Entries </span>
<span class="sd">            are filtered NES values (0 where FDR fails, or if not in the top_n).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>

    <span class="c1"># Make a copy of the input to avoid in-place modifications</span>
    <span class="n">gsea_dict</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">gsea_dict2</span><span class="p">)</span>

    <span class="c1"># Collect all possible gene set names and cell types</span>
    <span class="n">pathways</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">([])</span>
    <span class="n">cell_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">gsea_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">for</span> <span class="n">cell_type</span> <span class="ow">in</span> <span class="n">cell_types</span><span class="p">:</span>
        <span class="n">tmpRes</span> <span class="o">=</span> <span class="n">gsea_dict</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]</span><span class="o">.</span><span class="n">res2d</span>
        <span class="n">gene_set_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tmpRes</span><span class="p">[</span><span class="s1">&#39;Term&#39;</span><span class="p">])</span>
        <span class="n">pathways</span> <span class="o">=</span> <span class="n">pathways</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">gene_set_names</span><span class="p">)</span>

    <span class="c1"># Initialize NES DataFrame</span>
    <span class="n">nes_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">cell_types</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">pathways</span><span class="p">)</span>

    <span class="c1"># Apply FDR threshold and fill NES</span>
    <span class="k">for</span> <span class="n">cell_type</span> <span class="ow">in</span> <span class="n">cell_types</span><span class="p">:</span>
        <span class="n">ct_df</span> <span class="o">=</span> <span class="n">gsea_dict</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]</span><span class="o">.</span><span class="n">res2d</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ct_df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">ct_df</span><span class="p">[</span><span class="s1">&#39;Term&#39;</span><span class="p">]</span>
        <span class="c1"># Zero out NES where FDR is too high</span>
        <span class="n">ct_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ct_df</span><span class="p">[</span><span class="s1">&#39;FDR q-val&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">fdr_thr</span><span class="p">,</span> <span class="s2">&quot;NES&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nes_df</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">ct_df</span><span class="p">[</span><span class="s2">&quot;NES&quot;</span><span class="p">]</span>

    <span class="c1"># Convert NES to numeric just in case</span>
    <span class="n">nes_df</span> <span class="o">=</span> <span class="n">nes_df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;coerce&#39;</span><span class="p">)</span>

    <span class="c1"># Determine top_n positive and top_n negative for each cell type</span>
    <span class="n">selected_sets</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">cell_type</span> <span class="ow">in</span> <span class="n">cell_types</span><span class="p">:</span>
        <span class="n">ct_values</span> <span class="o">=</span> <span class="n">nes_df</span><span class="p">[</span><span class="n">cell_type</span><span class="p">]</span>
        <span class="c1"># Filter non-zero for positives and negatives</span>
        <span class="n">pos_mask</span> <span class="o">=</span> <span class="n">ct_values</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">neg_mask</span> <span class="o">=</span> <span class="n">ct_values</span> <span class="o">&lt;</span> <span class="mi">0</span>

        <span class="c1"># Select top_n largest positive NES</span>
        <span class="n">top_pos_index</span> <span class="o">=</span> <span class="n">ct_values</span><span class="p">[</span><span class="n">pos_mask</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">top_n</span><span class="p">)</span><span class="o">.</span><span class="n">index</span>
        <span class="c1"># Select top_n most negative NES (smallest ascending)</span>
        <span class="n">top_neg_index</span> <span class="o">=</span> <span class="n">ct_values</span><span class="p">[</span><span class="n">neg_mask</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">top_n</span><span class="p">)</span><span class="o">.</span><span class="n">index</span>

        <span class="n">selected_sets</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">top_pos_index</span><span class="p">)</span>
        <span class="n">selected_sets</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">top_neg_index</span><span class="p">)</span>

    <span class="c1"># Restrict DataFrame to the union of selected sets, converting the set to a list</span>
    <span class="n">selected_sets_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">selected_sets</span><span class="p">)</span>
    <span class="n">nes_df</span> <span class="o">=</span> <span class="n">nes_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">selected_sets_list</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">nes_df</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.classify.comp_ct_thresh" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">comp_ct_thresh</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">comp_ct_thresh</span><span class="p">(</span><span class="n">adata_c</span><span class="p">,</span> <span class="n">qTile</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">obs_name</span><span class="o">=</span><span class="s1">&#39;SCN_class_argmax&#39;</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Compute quantile thresholds for each cell type based on SCN scores.</p>
<p>For each cell type (excluding "rand"), this function calculates the qTile 
quantile of the SCN scores for cells predicted to belong to that type.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>adata_c</code></b>
              (<code><span title="anndata.AnnData">AnnData</span></code>)
          –
          <div class="doc-md-description">
            <p>Annotated data matrix with:
- <code>.obsm["SCN_score"]</code>: DataFrame of SCN scores.
- <code>.obs</code>: Observation metadata containing predictions.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>qTile</code></b>
              (<code>int</code>, default:
                  <code>0.05</code>
)
          –
          <div class="doc-md-description">
            <p>The quantile to compute (e.g., 0.05 for 5th percentile). Defaults to 0.05.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>obs_name</code></b>
              (<code>str</code>, default:
                  <code>&#39;SCN_class_argmax&#39;</code>
)
          –
          <div class="doc-md-description">
            <p>The column in <code>.obs</code> containing cell type predictions. Defaults to 'SCN_class_argmax'.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="pandas.DataFrame">DataFrame</span></code>
          –
          <div class="doc-md-description">
            <p>pd.DataFrame: A DataFrame where each row corresponds to a cell type </p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="pandas.DataFrame">DataFrame</span></code>
          –
          <div class="doc-md-description">
            <p>(excluding 'rand') and contains the computed quantile threshold.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="pandas.DataFrame">DataFrame</span></code>
          –
          <div class="doc-md-description">
            <p>Returns None if 'SCN_score' is not present in <code>adata_c.obsm</code>.</p>
          </div>
        </li>
    </ul>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/classify/categorize.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">comp_ct_thresh</span><span class="p">(</span><span class="n">adata_c</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span> <span class="n">qTile</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">obs_name</span><span class="o">=</span><span class="s1">&#39;SCN_class_argmax&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute quantile thresholds for each cell type based on SCN scores.</span>

<span class="sd">    For each cell type (excluding &quot;rand&quot;), this function calculates the qTile </span>
<span class="sd">    quantile of the SCN scores for cells predicted to belong to that type.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata_c (AnnData): Annotated data matrix with:</span>
<span class="sd">            - `.obsm[&quot;SCN_score&quot;]`: DataFrame of SCN scores.</span>
<span class="sd">            - `.obs`: Observation metadata containing predictions.</span>
<span class="sd">        qTile (int, optional): The quantile to compute (e.g., 0.05 for 5th percentile). Defaults to 0.05.</span>
<span class="sd">        obs_name (str, optional): The column in `.obs` containing cell type predictions. Defaults to &#39;SCN_class_argmax&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: A DataFrame where each row corresponds to a cell type </span>
<span class="sd">        (excluding &#39;rand&#39;) and contains the computed quantile threshold.</span>
<span class="sd">        Returns None if &#39;SCN_score&#39; is not present in `adata_c.obsm`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;SCN_score&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata_c</span><span class="o">.</span><span class="n">obsm_keys</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No .obsm[&#39;SCN_score&#39;] was found in the AnnData provided. You may need to run PySingleCellNet.scn_classify()&quot;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sampTab</span> <span class="o">=</span> <span class="n">adata_c</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">scnScores</span> <span class="o">=</span> <span class="n">adata_c</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s2">&quot;SCN_score&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">cts</span> <span class="o">=</span> <span class="n">scnScores</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;rand&#39;</span><span class="p">)</span>
        <span class="n">thrs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cts</span><span class="p">)),</span> <span class="n">index</span><span class="o">=</span><span class="n">cts</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ct</span> <span class="ow">in</span> <span class="n">cts</span><span class="p">:</span>
            <span class="c1"># print(ct)</span>
            <span class="n">templocs</span> <span class="o">=</span> <span class="n">sampTab</span><span class="p">[</span><span class="n">sampTab</span><span class="p">[</span><span class="n">obs_name</span><span class="p">]</span> <span class="o">==</span> <span class="n">ct</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
            <span class="n">tempscores</span> <span class="o">=</span> <span class="n">scnScores</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">templocs</span><span class="p">,</span> <span class="n">ct</span><span class="p">]</span>
            <span class="n">thrs</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ct</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">tempscores</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="n">qTile</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">thrs</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.classify.convert_diffExp_to_dict" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">convert_diffExp_to_dict</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">convert_diffExp_to_dict</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">uns_name</span><span class="o">=</span><span class="s1">&#39;rank_genes_groups&#39;</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Convert differential expression results from AnnData into a dictionary of DataFrames.</p>
<p>This function extracts differential expression results stored in <code>adata.uns[uns_name]</code> 
using Scanpy's <code>get.rank_genes_groups_df</code>, cleans the data, and organizes it into 
a dictionary where each key corresponds to a group and each value is a DataFrame 
of differential expression results for that group.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>adata</code></b>
              (<code><span title="anndata.AnnData">AnnData</span></code>)
          –
          <div class="doc-md-description">
            <p>Annotated data matrix containing differential expression results 
in <code>adata.uns</code>.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>uns_name</code></b>
              (<code>str</code>, default:
                  <code>&#39;rank_genes_groups&#39;</code>
)
          –
          <div class="doc-md-description">
            <p>Key in <code>adata.uns</code> where rank_genes_groups results 
are stored. Defaults to 'rank_genes_groups'.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
<b><code>dict</code></b>          –
          <div class="doc-md-description">
            <p>Dictionary mapping each group to a DataFrame of its differential </p>
          </div>
        </li>
        <li class="doc-section-item field-body">
          –
          <div class="doc-md-description">
            <p>expression results, with rows corresponding to genes and relevant statistics </p>
          </div>
        </li>
        <li class="doc-section-item field-body">
          –
          <div class="doc-md-description">
            <p>for each gene.</p>
          </div>
        </li>
    </ul>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/classify/comparison.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">convert_diffExp_to_dict</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">,</span>
    <span class="n">uns_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;rank_genes_groups&#39;</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert differential expression results from AnnData into a dictionary of DataFrames.</span>

<span class="sd">    This function extracts differential expression results stored in `adata.uns[uns_name]` </span>
<span class="sd">    using Scanpy&#39;s `get.rank_genes_groups_df`, cleans the data, and organizes it into </span>
<span class="sd">    a dictionary where each key corresponds to a group and each value is a DataFrame </span>
<span class="sd">    of differential expression results for that group.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata (AnnData): Annotated data matrix containing differential expression results </span>
<span class="sd">            in `adata.uns`.</span>
<span class="sd">        uns_name (str, optional): Key in `adata.uns` where rank_genes_groups results </span>
<span class="sd">            are stored. Defaults to &#39;rank_genes_groups&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: Dictionary mapping each group to a DataFrame of its differential </span>
<span class="sd">        expression results, with rows corresponding to genes and relevant statistics </span>
<span class="sd">        for each gene.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">scanpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sc</span>  <span class="c1"># Ensure Scanpy is imported</span>
    <span class="n">tempTab</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">rank_genes_groups_df</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">uns_name</span><span class="p">)</span>
    <span class="n">tempTab</span> <span class="o">=</span> <span class="n">tempTab</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="n">tempTab</span><span class="p">[</span><span class="s1">&#39;group&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>

    <span class="n">ans</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
        <span class="n">ans</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="o">=</span> <span class="n">tempTab</span><span class="p">[</span><span class="n">tempTab</span><span class="p">[</span><span class="s1">&#39;group&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">g</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.classify.create_classifier_report" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">create_classifier_report</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">create_classifier_report</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">ground_truth</span><span class="p">,</span> <span class="n">prediction</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Generate a classification report as a pandas DataFrame from an AnnData object.</p>
<p>This function computes a classification report using ground truth and prediction
columns in <code>adata.obs</code>. It supports both string and dictionary outputs from
<code>sklearn.metrics.classification_report</code> and transforms them into a standardized
DataFrame format.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>adata</code></b>
              (<code><span title="anndata.AnnData">AnnData</span></code>)
          –
          <div class="doc-md-description">
            <p>An annotated data matrix containing observations with
categorical truth and prediction labels.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>ground_truth</code></b>
              (<code>str</code>)
          –
          <div class="doc-md-description">
            <p>The column name in <code>adata.obs</code> containing the true
class labels.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>prediction</code></b>
              (<code>str</code>)
          –
          <div class="doc-md-description">
            <p>The column name in <code>adata.obs</code> containing the predicted
class labels.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code><span title="pandas.DataFrame">DataFrame</span></code>
          –
          <div class="doc-md-description">
            <p>pd.DataFrame: A DataFrame with columns ["Label", "Precision", "Recall",</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
              <code><span title="pandas.DataFrame">DataFrame</span></code>
          –
          <div class="doc-md-description">
            <p>"F1-Score", "Support"] summarizing classification metrics for each class.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Raises:</span></p>
    <ul>
        <li class="doc-section-item field-body">
              <code>ValueError</code>
            –
          <div class="doc-md-description">
            <p>If the classification report is neither a string nor a dictionary.</p>
          </div>
        </li>
    </ul>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/classify/classifier.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span>
<span class="normal">89</span>
<span class="normal">90</span>
<span class="normal">91</span>
<span class="normal">92</span>
<span class="normal">93</span>
<span class="normal">94</span>
<span class="normal">95</span>
<span class="normal">96</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">create_classifier_report</span><span class="p">(</span><span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">ground_truth</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">prediction</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a classification report as a pandas DataFrame from an AnnData object.</span>

<span class="sd">    This function computes a classification report using ground truth and prediction</span>
<span class="sd">    columns in `adata.obs`. It supports both string and dictionary outputs from</span>
<span class="sd">    `sklearn.metrics.classification_report` and transforms them into a standardized</span>
<span class="sd">    DataFrame format.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata (AnnData): An annotated data matrix containing observations with</span>
<span class="sd">            categorical truth and prediction labels.</span>
<span class="sd">        ground_truth (str): The column name in `adata.obs` containing the true</span>
<span class="sd">            class labels.</span>
<span class="sd">        prediction (str): The column name in `adata.obs` containing the predicted</span>
<span class="sd">            class labels.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: A DataFrame with columns [&quot;Label&quot;, &quot;Precision&quot;, &quot;Recall&quot;,</span>
<span class="sd">        &quot;F1-Score&quot;, &quot;Support&quot;] summarizing classification metrics for each class.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the classification report is neither a string nor a dictionary.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">report</span> <span class="o">=</span> <span class="n">classification_report</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">ground_truth</span><span class="p">],</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">prediction</span><span class="p">],</span><span class="n">labels</span><span class="o">=</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">ground_truth</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span><span class="p">,</span> <span class="n">output_dict</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Parse the sklearn classification report into a DataFrame</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">report</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">report</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">[</span><span class="mi">2</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;micro&#39;</span> <span class="ow">or</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;macro&#39;</span> <span class="ow">or</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;weighted&#39;</span><span class="p">:</span>
                <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">row</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">row</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">row</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">row</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Label&quot;</span><span class="p">,</span> <span class="s2">&quot;Precision&quot;</span><span class="p">,</span> <span class="s2">&quot;Recall&quot;</span><span class="p">,</span> <span class="s2">&quot;F1-Score&quot;</span><span class="p">,</span> <span class="s2">&quot;Support&quot;</span><span class="p">])</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;Precision&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Precision&quot;</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;coerce&#39;</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;Recall&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Recall&quot;</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;coerce&#39;</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;F1-Score&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;F1-Score&quot;</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;coerce&#39;</span><span class="p">)</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;Support&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;Support&quot;</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;coerce&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">report</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">report</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Label&quot;</span><span class="p">,</span> <span class="s2">&quot;Precision&quot;</span><span class="p">,</span> <span class="s2">&quot;Recall&quot;</span><span class="p">,</span> <span class="s2">&quot;F1-Score&quot;</span><span class="p">,</span> <span class="s2">&quot;Support&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Report must be a string or a dictionary.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.classify.deg" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">deg</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">deg</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">sample_obsvals</span><span class="o">=</span><span class="p">[],</span> <span class="n">limitto_obsvals</span><span class="o">=</span><span class="p">[],</span> <span class="n">cellgrp_obsname</span><span class="o">=</span><span class="s1">&#39;comb_cellgrp&#39;</span><span class="p">,</span> <span class="n">groupby_obsname</span><span class="o">=</span><span class="s1">&#39;comb_sampname&#39;</span><span class="p">,</span> <span class="n">ncells_per_sample</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">test_name</span><span class="o">=</span><span class="s1">&#39;t-test&#39;</span><span class="p">,</span> <span class="n">mask_var</span><span class="o">=</span><span class="s1">&#39;highly_variable&#39;</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Perform differential expression analysis on an AnnData object across specified cell groups and samples.</p>
<p>This function iterates over specified or all cell groups within the <code>adata</code> object and performs
differential expression analysis using the specified statistical test (e.g., t-test). It filters
groups based on the minimum number of cells per sample and returns the results in a structured dictionary.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>adata</code></b>
              (<code><span title="anndata.AnnData">AnnData</span></code>)
          –
          <div class="doc-md-description">
            <p>The annotated data matrix containing observations and variables.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>sample_obsvals</code></b>
              (<code>list</code>, default:
                  <code>[]</code>
)
          –
          <div class="doc-md-description">
            <p>List of sample observation values to include. Defaults to an empty list.
Impacts the sign of the test statistic.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>limitto_obsvals</code></b>
              (<code>list</code>, default:
                  <code>[]</code>
)
          –
          <div class="doc-md-description">
            <p>List of cell group observation values to limit the analysis to.
If empty, all cell groups in <code>adata</code> are tested. Defaults to an empty list.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>cellgrp_obsname</code></b>
              (<code>str</code>, default:
                  <code>&#39;comb_cellgrp&#39;</code>
)
          –
          <div class="doc-md-description">
            <p>The <code>.obs</code> column name in <code>adata</code> that holds the cell sub-groups.
Defaults to 'comb_cellgrp'.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>groupby_obsname</code></b>
              (<code>str</code>, default:
                  <code>&#39;comb_sampname&#39;</code>
)
          –
          <div class="doc-md-description">
            <p>The <code>.obs</code> column name in <code>adata</code> used to group observations for differential expression.
Defaults to 'comb_sampname'.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>ncells_per_sample</code></b>
              (<code>int</code>, default:
                  <code>30</code>
)
          –
          <div class="doc-md-description">
            <p>The minimum number of cells per sample required to perform the test.
Groups with fewer cells are skipped. Defaults to 30.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>test_name</code></b>
              (<code>str</code>, default:
                  <code>&#39;t-test&#39;</code>
)
          –
          <div class="doc-md-description">
            <p>The name of the statistical test to use for differential expression.
Defaults to 't-test'.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>mask_var</code></b>
              (<code>str</code>, default:
                  <code>&#39;highly_variable&#39;</code>
)
          –
          <div class="doc-md-description">
            <p>The name of the .var column indicating highly variable genes
Defaults to 'highly_variable'.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
<b><code>dict</code></b> (              <code>dict</code>
)          –
          <div class="doc-md-description">
            <p>A dictionary containing:
- 'sample_names': List of sample names used in the analysis.
- 'geneTab_dict': A dictionary where each key is a cell group name and each value is a DataFrame
  of differential expression results for that group.</p>
          </div>
        </li>
    </ul>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/classify/comparison.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">deg</span><span class="p">(</span>
    <span class="n">adata</span><span class="p">:</span> <span class="n">AnnData</span><span class="p">,</span>
    <span class="n">sample_obsvals</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[],</span>  <span class="c1"># Impacts the sign of the test statistic</span>
    <span class="n">limitto_obsvals</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[],</span>  <span class="c1"># Specifies which cell groups to test; if empty, tests all</span>
    <span class="n">cellgrp_obsname</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;comb_cellgrp&#39;</span><span class="p">,</span>  <span class="c1"># .obs column name holding the cell sub-groups to iterate over</span>
    <span class="n">groupby_obsname</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;comb_sampname&#39;</span><span class="p">,</span>  <span class="c1"># .obs column name to group by for differential expression</span>
    <span class="n">ncells_per_sample</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>  <span class="c1"># Minimum number of cells per sample required to perform the test</span>
    <span class="n">test_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;t-test&#39;</span><span class="p">,</span>  <span class="c1"># Name of the statistical test to use</span>
    <span class="n">mask_var</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;highly_variable&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform differential expression analysis on an AnnData object across specified cell groups and samples.</span>

<span class="sd">    This function iterates over specified or all cell groups within the `adata` object and performs</span>
<span class="sd">    differential expression analysis using the specified statistical test (e.g., t-test). It filters</span>
<span class="sd">    groups based on the minimum number of cells per sample and returns the results in a structured dictionary.</span>

<span class="sd">    Args:</span>
<span class="sd">        adata (AnnData): The annotated data matrix containing observations and variables.</span>
<span class="sd">        sample_obsvals (list, optional): List of sample observation values to include. Defaults to an empty list.</span>
<span class="sd">            Impacts the sign of the test statistic.</span>
<span class="sd">        limitto_obsvals (list, optional): List of cell group observation values to limit the analysis to.</span>
<span class="sd">            If empty, all cell groups in `adata` are tested. Defaults to an empty list.</span>
<span class="sd">        cellgrp_obsname (str, optional): The `.obs` column name in `adata` that holds the cell sub-groups.</span>
<span class="sd">            Defaults to &#39;comb_cellgrp&#39;.</span>
<span class="sd">        groupby_obsname (str, optional): The `.obs` column name in `adata` used to group observations for differential expression.</span>
<span class="sd">            Defaults to &#39;comb_sampname&#39;.</span>
<span class="sd">        ncells_per_sample (int, optional): The minimum number of cells per sample required to perform the test.</span>
<span class="sd">            Groups with fewer cells are skipped. Defaults to 30.</span>
<span class="sd">        test_name (str, optional): The name of the statistical test to use for differential expression.</span>
<span class="sd">            Defaults to &#39;t-test&#39;.</span>
<span class="sd">        mask_var (str, optional): The name of the .var column indicating highly variable genes</span>
<span class="sd">            Defaults to &#39;highly_variable&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: A dictionary containing:</span>
<span class="sd">            - &#39;sample_names&#39;: List of sample names used in the analysis.</span>
<span class="sd">            - &#39;geneTab_dict&#39;: A dictionary where each key is a cell group name and each value is a DataFrame</span>
<span class="sd">              of differential expression results for that group.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="c1"># Keys for the rank_genes_groups object</span>
    <span class="n">subset_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;names&#39;</span><span class="p">,</span> <span class="s1">&#39;scores&#39;</span><span class="p">,</span> <span class="s1">&#39;pvals&#39;</span><span class="p">,</span> <span class="s1">&#39;pvals_adj&#39;</span><span class="p">,</span> <span class="s1">&#39;logfoldchanges&#39;</span><span class="p">]</span>

    <span class="c1"># If no specific sample observation values are provided, use all unique values from adata</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_obsvals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sample_obsvals</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">groupby_obsname</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="c1"># Store the sample names in the result dictionary for later ordering of differential expression DataFrame</span>
    <span class="n">ans</span><span class="p">[</span><span class="s1">&#39;sample_names&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample_obsvals</span>

    <span class="c1"># Retrieve unique cell group names from the AnnData object</span>
    <span class="n">cellgroup_names_in_anndata</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cellgrp_obsname</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

    <span class="c1"># If limitto_obsvals is provided, validate and set the cell groups to test</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limitto_obsvals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Identify any provided cell groups that are not present in adata</span>
        <span class="n">unique_to_input</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">limitto_obsvals</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cellgroup_names_in_anndata</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_to_input</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The argument cellgrp_obsname has values that are not present in adata: </span><span class="si">{</span><span class="n">unique_to_input</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cellgroup_names</span> <span class="o">=</span> <span class="n">limitto_obsvals</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If no limit is set, use all available cell groups</span>
        <span class="n">cellgroup_names</span> <span class="o">=</span> <span class="n">cellgroup_names_in_anndata</span>

    <span class="c1"># Initialize a temporary dictionary to store differential expression results</span>
    <span class="n">tmp_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="c1"># Create a mask to filter adata for the specified sample observation values</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">groupby_obsname</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">sample_obsvals</span><span class="p">)</span>
    <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">convert_rankGeneGroup_to_df</span><span class="p">(</span><span class="n">rgg</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">list_of_keys</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the rank_genes_groups result from AnnData to a pandas DataFrame.</span>

<span class="sd">        Args:</span>
<span class="sd">            rgg (dict): The rank_genes_groups result from AnnData.</span>
<span class="sd">            list_of_keys (list): List of keys to extract from the rank_genes_groups result.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: A DataFrame containing the extracted rank genes information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize a dictionary to hold arrays for each key</span>
        <span class="n">arrays_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">list_of_keys</span><span class="p">:</span>
            <span class="n">recarray</span> <span class="o">=</span> <span class="n">rgg</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">field_name</span> <span class="o">=</span> <span class="n">recarray</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Get the first field name from the structured array</span>
            <span class="n">arrays_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">recarray</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span>

        <span class="c1"># Convert the dictionary of arrays to a DataFrame</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">arrays_dict</span><span class="p">)</span>

    <span class="c1"># Iterate over each cell group to perform differential expression analysis</span>
    <span class="k">for</span> <span class="n">cell_group</span> <span class="ow">in</span> <span class="n">cellgroup_names</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cell group: </span><span class="si">{</span><span class="n">cell_group</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Subset the AnnData object for the current cell group</span>
        <span class="n">adTmp</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cellgrp_obsname</span><span class="p">]</span> <span class="o">==</span> <span class="n">cell_group</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Count the number of cells per sample within the cell group</span>
        <span class="n">vcounts</span> <span class="o">=</span> <span class="n">adTmp</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">groupby_obsname</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>

        <span class="c1"># Check if there are exactly two samples and each has at least ncells_per_sample cells</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vcounts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">vcounts</span> <span class="o">&gt;=</span> <span class="n">ncells_per_sample</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="c1"># Perform differential expression analysis using the specified test</span>
            <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">rank_genes_groups</span><span class="p">(</span>
                <span class="n">adTmp</span><span class="p">,</span>
                <span class="n">use_raw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">groupby</span><span class="o">=</span><span class="n">groupby_obsname</span><span class="p">,</span>
                <span class="n">groups</span><span class="o">=</span><span class="p">[</span><span class="n">sample_obsvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                <span class="n">reference</span><span class="o">=</span><span class="n">sample_obsvals</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">method</span><span class="o">=</span><span class="n">test_name</span><span class="p">,</span>
                <span class="n">mask_var</span><span class="o">=</span><span class="n">mask_var</span>
            <span class="p">)</span>

            <span class="c1"># Convert the rank_genes_groups result to a DataFrame and store it in tmp_dict</span>
            <span class="n">tmp_dict</span><span class="p">[</span><span class="n">cell_group</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_rankGeneGroup_to_df</span><span class="p">(</span><span class="n">adTmp</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s1">&#39;rank_genes_groups&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">subset_keys</span><span class="p">)</span>
            <span class="c1"># Alternative method to get the DataFrame (commented out)</span>
            <span class="c1"># tmp_dict[cell_group] = sc.get.rank_genes_groups_df(adTmp, cell_group)</span>

    <span class="c1"># Store the differential expression results in the result dictionary</span>
    <span class="n">ans</span><span class="p">[</span><span class="s1">&#39;geneTab_dict&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_dict</span>

    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.classify.graph_from_nodes_and_edges" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">graph_from_nodes_and_edges</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">graph_from_nodes_and_edges</span><span class="p">(</span><span class="n">edge_dataframe</span><span class="p">,</span> <span class="n">node_dataframe</span><span class="p">,</span> <span class="n">attribution_column_names</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Create an iGraph graph from provided node and edge dataframes.</p>
<p>This function constructs an iGraph graph using nodes defined in 
<code>node_dataframe</code> and edges defined in <code>edge_dataframe</code>. Each vertex 
is assigned attributes based on specified columns, and edges are 
created according to 'from' and 'to' columns in the edge dataframe.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>edge_dataframe</code></b>
              (<code><span title="pandas.DataFrame">DataFrame</span></code>)
          –
          <div class="doc-md-description">
            <p>A DataFrame containing edge 
information with at least 'from' and 'to' columns indicating 
source and target node identifiers.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>node_dataframe</code></b>
              (<code><span title="pandas.DataFrame">DataFrame</span></code>)
          –
          <div class="doc-md-description">
            <p>A DataFrame containing node 
information. Must include an 'id' column for vertex identifiers 
and any other columns specified in <code>attribution_column_names</code>.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>attribution_column_names</code></b>
              (<code>list of str</code>)
          –
          <div class="doc-md-description">
            <p>List of column names from 
<code>node_dataframe</code> whose values will be assigned as attributes 
to the corresponding vertices in the graph.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>directed</code></b>
              (<code>bool</code>, default:
                  <code>True</code>
)
          –
          <div class="doc-md-description">
            <p>Whether the graph should be directed. 
Defaults to True.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
          –
          <div class="doc-md-description">
            <p>ig.Graph: An iGraph graph constructed from the given nodes and edges, </p>
          </div>
        </li>
        <li class="doc-section-item field-body">
          –
          <div class="doc-md-description">
            <p>with vertex attributes and labels set according to the provided data.</p>
          </div>
        </li>
    </ul>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/classify/categorize.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">graph_from_nodes_and_edges</span><span class="p">(</span><span class="n">edge_dataframe</span><span class="p">,</span> <span class="n">node_dataframe</span><span class="p">,</span> <span class="n">attribution_column_names</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create an iGraph graph from provided node and edge dataframes.</span>

<span class="sd">    This function constructs an iGraph graph using nodes defined in </span>
<span class="sd">    `node_dataframe` and edges defined in `edge_dataframe`. Each vertex </span>
<span class="sd">    is assigned attributes based on specified columns, and edges are </span>
<span class="sd">    created according to &#39;from&#39; and &#39;to&#39; columns in the edge dataframe.</span>

<span class="sd">    Args:</span>
<span class="sd">        edge_dataframe (pd.DataFrame): A DataFrame containing edge </span>
<span class="sd">            information with at least &#39;from&#39; and &#39;to&#39; columns indicating </span>
<span class="sd">            source and target node identifiers.</span>
<span class="sd">        node_dataframe (pd.DataFrame): A DataFrame containing node </span>
<span class="sd">            information. Must include an &#39;id&#39; column for vertex identifiers </span>
<span class="sd">            and any other columns specified in `attribution_column_names`.</span>
<span class="sd">        attribution_column_names (list of str): List of column names from </span>
<span class="sd">            `node_dataframe` whose values will be assigned as attributes </span>
<span class="sd">            to the corresponding vertices in the graph.</span>
<span class="sd">        directed (bool, optional): Whether the graph should be directed. </span>
<span class="sd">            Defaults to True.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ig.Graph: An iGraph graph constructed from the given nodes and edges, </span>
<span class="sd">        with vertex attributes and labels set according to the provided data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gra</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">)</span>
    <span class="n">attr</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">attr_names</span> <span class="ow">in</span> <span class="n">attribution_column_names</span><span class="p">:</span>
        <span class="n">attr</span><span class="p">[</span><span class="n">attr_names</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_dataframe</span><span class="p">[</span><span class="n">attr_names</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

    <span class="n">gra</span><span class="o">.</span><span class="n">add_vertices</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">node_dataframe</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span> <span class="n">attributes</span><span class="o">=</span><span class="n">attr</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">edge_dataframe</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
        <span class="n">tempsource</span> <span class="o">=</span> <span class="n">edge_dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;from&#39;</span><span class="p">]</span>
        <span class="n">temptarget</span> <span class="o">=</span> <span class="n">edge_dataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">&#39;to&#39;</span><span class="p">]</span>
        <span class="n">gra</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="n">tempsource</span><span class="p">,</span> <span class="n">temptarget</span><span class="p">)])</span>

    <span class="n">gra</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gra</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">gra</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.classify.gsea_on_deg" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">gsea_on_deg</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">gsea_on_deg</span><span class="p">(</span><span class="n">deg_res</span><span class="p">,</span> <span class="n">genesets_name</span><span class="p">,</span> <span class="n">genesets</span><span class="p">,</span> <span class="n">permutation_num</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">min_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Perform Gene Set Enrichment Analysis (GSEA) on differential expression results.</p>
<p>Applies GSEA using <code>gseapy.prerank</code> for each group in the differential 
expression results dictionary against provided gene sets.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>deg_res</code></b>
              (<code>dict</code>)
          –
          <div class="doc-md-description">
            <p>Dictionary mapping cell group names to DataFrames 
of differential expression results. Each DataFrame must contain 
columns 'names' (gene names) and 'scores' (ranking scores).</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>genesets_name</code></b>
              (<code>str</code>)
          –
          <div class="doc-md-description">
            <p>Name of the gene set collection (not actively used).</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>genesets</code></b>
              (<code>dict</code>)
          –
          <div class="doc-md-description">
            <p>Dictionary of gene sets where keys are gene set 
names and values are lists of genes.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>permutation_num</code></b>
              (<code>int</code>, default:
                  <code>100</code>
)
          –
          <div class="doc-md-description">
            <p>Number of permutations for GSEA. 
Defaults to 100.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>threads</code></b>
              (<code>int</code>, default:
                  <code>4</code>
)
          –
          <div class="doc-md-description">
            <p>Number of parallel threads to use. Defaults to 4.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>seed</code></b>
              (<code>int</code>, default:
                  <code>3</code>
)
          –
          <div class="doc-md-description">
            <p>Random seed for reproducibility. Defaults to 3.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>min_size</code></b>
              (<code>int</code>, default:
                  <code>10</code>
)
          –
          <div class="doc-md-description">
            <p>Minimum gene set size to consider. Defaults to 10.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>max_size</code></b>
              (<code>int</code>, default:
                  <code>500</code>
)
          –
          <div class="doc-md-description">
            <p>Maximum gene set size to consider. Defaults to 500.</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
<b><code>dict</code></b> (              <code>dict</code>
)          –
          <div class="doc-md-description">
            <p>Dictionary where keys are cell group names and values are 
GSEA result objects returned by <code>gseapy.prerank</code>.</p>
          </div>
        </li>
    </ul>


<details class="example" open>
  <summary>Example</summary>
  <blockquote>
<blockquote>
<blockquote>
<p>deg_results = {
...     'Cluster1': pd.DataFrame({'names': ['GeneA', 'GeneB'], 'scores': [2.5, -1.3]}),
...     'Cluster2': pd.DataFrame({'names': ['GeneC', 'GeneD'], 'scores': [1.2, -2.1]})
... }
gene_sets = {'Pathway1': ['GeneA', 'GeneC'], 'Pathway2': ['GeneB', 'GeneD']}
results = gsea_on_deg(deg_results, 'ExampleGeneSets', gene_sets)</p>
</blockquote>
</blockquote>
</blockquote>
</details>
            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/classify/comparison.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">gsea_on_deg</span><span class="p">(</span>
    <span class="n">deg_res</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="n">genesets_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">genesets</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="n">permutation_num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="n">threads</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">min_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">max_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">500</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform Gene Set Enrichment Analysis (GSEA) on differential expression results.</span>

<span class="sd">    Applies GSEA using `gseapy.prerank` for each group in the differential </span>
<span class="sd">    expression results dictionary against provided gene sets.</span>

<span class="sd">    Args:</span>
<span class="sd">        deg_res (dict): Dictionary mapping cell group names to DataFrames </span>
<span class="sd">            of differential expression results. Each DataFrame must contain </span>
<span class="sd">            columns &#39;names&#39; (gene names) and &#39;scores&#39; (ranking scores).</span>
<span class="sd">        genesets_name (str): Name of the gene set collection (not actively used).</span>
<span class="sd">        genesets (dict): Dictionary of gene sets where keys are gene set </span>
<span class="sd">            names and values are lists of genes.</span>
<span class="sd">        permutation_num (int, optional): Number of permutations for GSEA. </span>
<span class="sd">            Defaults to 100.</span>
<span class="sd">        threads (int, optional): Number of parallel threads to use. Defaults to 4.</span>
<span class="sd">        seed (int, optional): Random seed for reproducibility. Defaults to 3.</span>
<span class="sd">        min_size (int, optional): Minimum gene set size to consider. Defaults to 10.</span>
<span class="sd">        max_size (int, optional): Maximum gene set size to consider. Defaults to 500.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: Dictionary where keys are cell group names and values are </span>
<span class="sd">            GSEA result objects returned by `gseapy.prerank`.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; deg_results = {</span>
<span class="sd">        ...     &#39;Cluster1&#39;: pd.DataFrame({&#39;names&#39;: [&#39;GeneA&#39;, &#39;GeneB&#39;], &#39;scores&#39;: [2.5, -1.3]}),</span>
<span class="sd">        ...     &#39;Cluster2&#39;: pd.DataFrame({&#39;names&#39;: [&#39;GeneC&#39;, &#39;GeneD&#39;], &#39;scores&#39;: [1.2, -2.1]})</span>
<span class="sd">        ... }</span>
<span class="sd">        &gt;&gt;&gt; gene_sets = {&#39;Pathway1&#39;: [&#39;GeneA&#39;, &#39;GeneC&#39;], &#39;Pathway2&#39;: [&#39;GeneB&#39;, &#39;GeneD&#39;]}</span>
<span class="sd">        &gt;&gt;&gt; results = gsea_on_deg(deg_results, &#39;ExampleGeneSets&#39;, gene_sets)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">diff_gene_tables</span> <span class="o">=</span> <span class="n">deg_res</span>
    <span class="n">cellgrp_vals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">diff_gene_tables</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">cellgrp</span> <span class="ow">in</span> <span class="n">cellgrp_vals</span><span class="p">:</span>
        <span class="n">atab</span> <span class="o">=</span> <span class="n">diff_gene_tables</span><span class="p">[</span><span class="n">cellgrp</span><span class="p">]</span>
        <span class="n">atab</span> <span class="o">=</span> <span class="n">atab</span><span class="p">[[</span><span class="s1">&#39;names&#39;</span><span class="p">,</span> <span class="s1">&#39;scores&#39;</span><span class="p">]]</span>
        <span class="n">atab</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">]</span>
        <span class="n">pre_res</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">prerank</span><span class="p">(</span>
            <span class="n">rnk</span><span class="o">=</span><span class="n">atab</span><span class="p">,</span>
            <span class="n">gene_sets</span><span class="o">=</span><span class="n">genesets</span><span class="p">,</span>
            <span class="n">permutation_num</span><span class="o">=</span><span class="n">permutation_num</span><span class="p">,</span>
            <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">threads</span><span class="o">=</span><span class="n">threads</span><span class="p">,</span>
            <span class="n">no_plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
            <span class="n">min_size</span><span class="o">=</span><span class="n">min_size</span><span class="p">,</span>
            <span class="n">max_size</span><span class="o">=</span><span class="n">max_size</span>
        <span class="p">)</span>
        <span class="n">ans</span><span class="p">[</span><span class="n">cellgrp</span><span class="p">]</span> <span class="o">=</span> <span class="n">pre_res</span>
    <span class="k">return</span> <span class="n">ans</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="pySingleCellNet.classify.paga_connectivities_to_igraph" class="doc doc-heading">
            <span class="doc doc-object-name doc-function-name">paga_connectivities_to_igraph</span>


</h3>
<div class="doc-signature highlight"><pre><span></span><code><span class="nf">paga_connectivities_to_igraph</span><span class="p">(</span><span class="n">adInput</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">use_rep</span><span class="o">=</span><span class="s1">&#39;X_pca&#39;</span><span class="p">,</span> <span class="n">n_comps</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">paga_key</span><span class="o">=</span><span class="s1">&#39;paga&#39;</span><span class="p">,</span> <span class="n">connectivities_key</span><span class="o">=</span><span class="s1">&#39;connectivities&#39;</span><span class="p">,</span> <span class="n">group_key</span><span class="o">=</span><span class="s1">&#39;auto_cluster&#39;</span><span class="p">)</span>
</code></pre></div>

    <div class="doc doc-contents ">

        <p>Convert a PAGA adjacency matrix to an undirected iGraph object and add 'ncells' 
attribute for each vertex based on the number of cells in each cluster.</p>
<p>This function extracts the PAGA connectivity matrix from <code>adata.uns</code>, thresholds 
the edges, constructs an undirected iGraph graph, and assigns vertex names and 
the number of cells in each cluster.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <ul>
        <li class="doc-section-item field-body">
            <b><code>adInput</code></b>
              (<code><span title="anndata.AnnData">AnnData</span></code>)
          –
          <div class="doc-md-description">
            <p>The AnnData object containing:
- <code>adata.uns[paga_key][connectivities_key]</code>: The PAGA adjacency matrix (CSR format).
- <code>adata.obs[group_key].cat.categories</code>: The node labels.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>n_neighbors</code></b>
              (<code>int</code>, default:
                  <code>10</code>
)
          –
          <div class="doc-md-description">
            <p>Number of neighbors for computing nearest neighbors. Defaults to 10.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>use_rep</code></b>
              (<code>str</code>, default:
                  <code>&#39;X_pca&#39;</code>
)
          –
          <div class="doc-md-description">
            <p>The representation to use. Defaults to 'X_pca'.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>n_comps</code></b>
              (<code>int</code>, default:
                  <code>30</code>
)
          –
          <div class="doc-md-description">
            <p>Number of principal components. Defaults to 30.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>threshold</code></b>
              (<code>float</code>, default:
                  <code>0.05</code>
)
          –
          <div class="doc-md-description">
            <p>Minimum edge weight to include. Defaults to 0.05.</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>paga_key</code></b>
              (<code>str</code>, default:
                  <code>&#39;paga&#39;</code>
)
          –
          <div class="doc-md-description">
            <p>Key in <code>adata.uns</code> for PAGA results. Defaults to "paga".</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>connectivities_key</code></b>
              (<code>str</code>, default:
                  <code>&#39;connectivities&#39;</code>
)
          –
          <div class="doc-md-description">
            <p>Key for connectivity matrix in <code>adata.uns[paga_key]</code>. Defaults to "connectivities".</p>
          </div>
        </li>
        <li class="doc-section-item field-body">
            <b><code>group_key</code></b>
              (<code>str</code>, default:
                  <code>&#39;auto_cluster&#39;</code>
)
          –
          <div class="doc-md-description">
            <p>The <code>.obs</code> column name with cluster labels. Defaults to "auto_cluster".</p>
          </div>
        </li>
    </ul>


<p><span class="doc-section-title">Returns:</span></p>
    <ul>
        <li class="doc-section-item field-body">
          –
          <div class="doc-md-description">
            <p>ig.Graph: An undirected graph with edges meeting the threshold, edge weights assigned, </p>
          </div>
        </li>
        <li class="doc-section-item field-body">
          –
          <div class="doc-md-description">
            <p>vertex names set to cluster categories when possible, and each vertex has an 'ncells' attribute.</p>
          </div>
        </li>
    </ul>

            <details class="quote">
              <summary>Source code in <code>src/pySingleCellNet/classify/categorize.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">paga_connectivities_to_igraph</span><span class="p">(</span>
    <span class="n">adInput</span><span class="p">,</span>
    <span class="n">n_neighbors</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
    <span class="n">use_rep</span><span class="o">=</span><span class="s1">&#39;X_pca&#39;</span><span class="p">,</span>
    <span class="n">n_comps</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
    <span class="n">threshold</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> 
    <span class="n">paga_key</span><span class="o">=</span><span class="s2">&quot;paga&quot;</span><span class="p">,</span> 
    <span class="n">connectivities_key</span><span class="o">=</span><span class="s2">&quot;connectivities&quot;</span><span class="p">,</span> 
    <span class="n">group_key</span><span class="o">=</span><span class="s2">&quot;auto_cluster&quot;</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a PAGA adjacency matrix to an undirected iGraph object and add &#39;ncells&#39; </span>
<span class="sd">    attribute for each vertex based on the number of cells in each cluster.</span>

<span class="sd">    This function extracts the PAGA connectivity matrix from `adata.uns`, thresholds </span>
<span class="sd">    the edges, constructs an undirected iGraph graph, and assigns vertex names and </span>
<span class="sd">    the number of cells in each cluster.</span>

<span class="sd">    Args:</span>
<span class="sd">        adInput (AnnData): The AnnData object containing:</span>
<span class="sd">            - `adata.uns[paga_key][connectivities_key]`: The PAGA adjacency matrix (CSR format).</span>
<span class="sd">            - `adata.obs[group_key].cat.categories`: The node labels.</span>
<span class="sd">        n_neighbors (int, optional): Number of neighbors for computing nearest neighbors. Defaults to 10.</span>
<span class="sd">        use_rep (str, optional): The representation to use. Defaults to &#39;X_pca&#39;.</span>
<span class="sd">        n_comps (int, optional): Number of principal components. Defaults to 30.</span>
<span class="sd">        threshold (float, optional): Minimum edge weight to include. Defaults to 0.05.</span>
<span class="sd">        paga_key (str, optional): Key in `adata.uns` for PAGA results. Defaults to &quot;paga&quot;.</span>
<span class="sd">        connectivities_key (str, optional): Key for connectivity matrix in `adata.uns[paga_key]`. Defaults to &quot;connectivities&quot;.</span>
<span class="sd">        group_key (str, optional): The `.obs` column name with cluster labels. Defaults to &quot;auto_cluster&quot;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        ig.Graph: An undirected graph with edges meeting the threshold, edge weights assigned, </span>
<span class="sd">        vertex names set to cluster categories when possible, and each vertex has an &#39;ncells&#39; attribute.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Copy so as to avoid altering the original AnnData object</span>
    <span class="n">adata</span> <span class="o">=</span> <span class="n">adInput</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Compute PCA, knn, and PAGA</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">pca</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">n_comps</span><span class="p">,</span> <span class="n">mask_var</span><span class="o">=</span><span class="s1">&#39;highly_variable&#39;</span><span class="p">)</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">pp</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">use_rep</span><span class="o">=</span><span class="n">use_rep</span><span class="p">,</span> <span class="n">n_pcs</span><span class="o">=</span><span class="n">n_comps</span><span class="p">)</span>
    <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">paga</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="n">group_key</span><span class="p">)</span>

    <span class="c1"># Extract the PAGA connectivity matrix</span>
    <span class="n">adjacency_csr</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="n">paga_key</span><span class="p">][</span><span class="n">connectivities_key</span><span class="p">]</span>
    <span class="n">adjacency_coo</span> <span class="o">=</span> <span class="n">adjacency_csr</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span>

    <span class="c1"># Build edge list based on threshold</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">adjacency_coo</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">adjacency_coo</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">adjacency_coo</span><span class="o">.</span><span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">val</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">:</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
            <span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="c1"># Create the graph</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">adjacency_csr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span>

    <span class="c1"># Assign vertex names and &#39;ncells&#39; attribute if group_key exists in adata.obs</span>
    <span class="k">if</span> <span class="n">group_key</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">:</span>
        <span class="c1"># Get cluster categories</span>
        <span class="n">categories</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">group_key</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span>

        <span class="c1"># Calculate the number of cells per category</span>
        <span class="n">cell_counts_series</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">group_key</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">categories</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">cell_counts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cell_counts_series</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">categories</span><span class="p">)</span> <span class="o">==</span> <span class="n">adjacency_csr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c1"># Assign vertex names and &#39;ncells&#39; attribute</span>
            <span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">categories</span><span class="p">)</span>
            <span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">categories</span><span class="p">)</span>
            <span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s2">&quot;ncells&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_counts</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Warning: adjacency matrix size (</span><span class="si">{</span><span class="n">adjacency_csr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">) &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;differs from number of categories (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">categories</span><span class="p">)</span><span class="si">}</span><span class="s2">). &quot;</span>
                <span class="s2">&quot;Vertex names and &#39;ncells&#39; will not be fully assigned.&quot;</span>
            <span class="p">)</span>
            <span class="c1"># Even if the sizes don&#39;t match, still assign available &#39;ncells&#39; for existing categories</span>
            <span class="n">g</span><span class="o">.</span><span class="n">vs</span><span class="p">[</span><span class="s2">&quot;ncells&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_counts</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Warning: </span><span class="si">{</span><span class="n">group_key</span><span class="si">}</span><span class="s2"> not found in adata.obs; &quot;</span>
            <span class="s2">&quot;vertex names and &#39;ncells&#39; will not be assigned.&quot;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">g</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2024 Cahan Lab
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": ".", "features": ["content.footnote.tooltips", "navigation.expand", "toc.integrate"], "search": "assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="assets/javascripts/bundle.88dd0f4e.min.js"></script>
      
        <script src="javascripts/extra.js"></script>
      
    
  </body>
</html>